{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to RoDevs Helpers Documentation! Welcome to our documentation, here you will find articles that will help you expand your development knowledge! Our main objective is to encourage people to learn something new whenever they can, that's why we want to make a special site for it, by which you can expand your knowledge. Disclaimer. This documentation is in its beta phase . Even though they are reviewed but there are still possibilities of minor mistakes. These include misspellings, typos, etc. If you ever find any mistake then please report us instantly. You can also give us your feedback here: Report and Reviews","title":"Home"},{"location":"#welcome-to-rodevs-helpers-documentation","text":"Welcome to our documentation, here you will find articles that will help you expand your development knowledge! Our main objective is to encourage people to learn something new whenever they can, that's why we want to make a special site for it, by which you can expand your knowledge.","title":"Welcome to RoDevs Helpers Documentation!"},{"location":"#disclaimer","text":"This documentation is in its beta phase . Even though they are reviewed but there are still possibilities of minor mistakes. These include misspellings, typos, etc. If you ever find any mistake then please report us instantly. You can also give us your feedback here: Report and Reviews","title":"Disclaimer."},{"location":"Luau-Learning/Attributes/","text":"What are attributes? In Roblox Attributes of an instance are just like it's properties but custom properties. It means you can create them, remove them, edit them. They are pretty useful and they also save you from having multiple value instance like string value , bool value , int value . You can create them manually or by using a script. In this guide we will be creating them via scripts . Creating Attributes! SetAttribute() In order to create an attribute we use a method SetAttribute() . This method takes two arguments: Name Of the attribute Value local Part = workspace . Part --referencing a part in the workspace --Creaing attribute of part Part : SetAttribute ( \"Nickname\" , \"eden\" ) In the above code we created an attribute of part and named that attribute Nickname and set its value to a string \"eden\". Now if you run the script then you can find this attribute in the Properties window. But now how can we use this attribute?. Getting Attributes! GetAttribute() When ever we want to get value of an attribute of any instance, we call a method GetAtribute() over the instance. This method takes only 1 argument: Name of the attribute. local Part = workspace . Part --creating an attribute of part Part : SetAttribute ( \"Nickname\" , \"eden\" ) --getting value of the attribute \"Nickname\". local Nickname = Part : GetAttribute ( \"Nickname\" ) print ( Nickname ) Output: eden Note: You can't get value of any attribute by Part.NameOfAttribute . Name of the attribute must be String . Getting all attributes! GetAttributes() In order to get all attributes of an instance you need to call GetAttributes() ( GetAtrributes() and GetAtrribute() two different methods ) over the instance. This method returns a dictionary of names and the values of all attributes of the instance. Sample Code: local Part = workspace . Part --creating an attribute of part Part : SetAttribute ( \"Nickname\" , \"eden\" ) Part : SetAttribute ( \"IsAlive\" , true ) --getting value of all the attributes. for Name , Value in pairs ( Part : GetAttributes ()) do print ( Name , Value ) end Output: Nickname eden IsAlive true Editing/Removing attributes! Now if we want to change nickname of the part to \"heaven\". We will again use SetAttribute() . If the attribute with the given name already exist it just change it's value but if the attribute with this name doesn't exist, it creates the attribute then set its value. Here is an example code: local Part = workspace . Part --creating an attribute of part Part : SetAttribute ( \"Nickname\" , \"eden\" ) local Nickname = Part : GetAttribute () print ( Nickname ) Part : SetAttribute ( \"Nickname\" , \"Heaven\" ) Nickname = Part : GetAttribute ( \"Nickname\" ) print ( Nickname ) Output: eden Heaven If we want to remove any attributes we will just set it's value to nil . Part : SetAttribute ( \"IsAlive\" , nil ) Boom! its gone now. Detecting Changes! GetAttributeChangedSignal() If we want to detect change of any specific attribute we use GetAttributeChangedSignal() . AttributeChanged If we want to detect change of any attribute we use AttributeChanged Here is an example for you! Part : GetAttributeChangedSignal ( \"Nickname\" ): Connect ( function () print ( \"nickname changed\" ) end ) Part . AttributeChanged : Connect ( function ( nameoftheattrubute ) print ( nameoftheattribute .. \"Changed\" ) end ) Thanks For Reading In case of any mistake feel free to report this article and don't forget to leave your reviews!","title":"Attributes"},{"location":"Luau-Learning/Attributes/#what-are-attributes","text":"In Roblox Attributes of an instance are just like it's properties but custom properties. It means you can create them, remove them, edit them. They are pretty useful and they also save you from having multiple value instance like string value , bool value , int value . You can create them manually or by using a script. In this guide we will be creating them via scripts .","title":"What are attributes?"},{"location":"Luau-Learning/Attributes/#creating-attributes","text":"","title":"Creating Attributes!"},{"location":"Luau-Learning/Attributes/#setattribute","text":"In order to create an attribute we use a method SetAttribute() . This method takes two arguments: Name Of the attribute Value local Part = workspace . Part --referencing a part in the workspace --Creaing attribute of part Part : SetAttribute ( \"Nickname\" , \"eden\" ) In the above code we created an attribute of part and named that attribute Nickname and set its value to a string \"eden\". Now if you run the script then you can find this attribute in the Properties window. But now how can we use this attribute?.","title":"SetAttribute()"},{"location":"Luau-Learning/Attributes/#getting-attributes","text":"","title":"Getting Attributes!"},{"location":"Luau-Learning/Attributes/#getattribute","text":"When ever we want to get value of an attribute of any instance, we call a method GetAtribute() over the instance. This method takes only 1 argument: Name of the attribute. local Part = workspace . Part --creating an attribute of part Part : SetAttribute ( \"Nickname\" , \"eden\" ) --getting value of the attribute \"Nickname\". local Nickname = Part : GetAttribute ( \"Nickname\" ) print ( Nickname ) Output: eden Note: You can't get value of any attribute by Part.NameOfAttribute . Name of the attribute must be String .","title":"GetAttribute()"},{"location":"Luau-Learning/Attributes/#getting-all-attributes","text":"","title":"Getting all attributes!"},{"location":"Luau-Learning/Attributes/#getattributes","text":"In order to get all attributes of an instance you need to call GetAttributes() ( GetAtrributes() and GetAtrribute() two different methods ) over the instance. This method returns a dictionary of names and the values of all attributes of the instance. Sample Code: local Part = workspace . Part --creating an attribute of part Part : SetAttribute ( \"Nickname\" , \"eden\" ) Part : SetAttribute ( \"IsAlive\" , true ) --getting value of all the attributes. for Name , Value in pairs ( Part : GetAttributes ()) do print ( Name , Value ) end Output: Nickname eden IsAlive true","title":"GetAttributes()"},{"location":"Luau-Learning/Attributes/#editingremoving-attributes","text":"Now if we want to change nickname of the part to \"heaven\". We will again use SetAttribute() . If the attribute with the given name already exist it just change it's value but if the attribute with this name doesn't exist, it creates the attribute then set its value. Here is an example code: local Part = workspace . Part --creating an attribute of part Part : SetAttribute ( \"Nickname\" , \"eden\" ) local Nickname = Part : GetAttribute () print ( Nickname ) Part : SetAttribute ( \"Nickname\" , \"Heaven\" ) Nickname = Part : GetAttribute ( \"Nickname\" ) print ( Nickname ) Output: eden Heaven If we want to remove any attributes we will just set it's value to nil . Part : SetAttribute ( \"IsAlive\" , nil ) Boom! its gone now.","title":"Editing/Removing attributes!"},{"location":"Luau-Learning/Attributes/#detecting-changes","text":"","title":"Detecting Changes!"},{"location":"Luau-Learning/Attributes/#getattributechangedsignal","text":"If we want to detect change of any specific attribute we use GetAttributeChangedSignal() .","title":"GetAttributeChangedSignal()"},{"location":"Luau-Learning/Attributes/#attributechanged","text":"If we want to detect change of any attribute we use AttributeChanged Here is an example for you! Part : GetAttributeChangedSignal ( \"Nickname\" ): Connect ( function () print ( \"nickname changed\" ) end ) Part . AttributeChanged : Connect ( function ( nameoftheattrubute ) print ( nameoftheattribute .. \"Changed\" ) end )","title":"AttributeChanged"},{"location":"Luau-Learning/Attributes/#thanks-for-reading","text":"In case of any mistake feel free to report this article and don't forget to leave your reviews!","title":"Thanks For Reading"},{"location":"Luau-Learning/Basics_of_Functions/","text":"Basics of Functions I don't like typing a lot of code, YOU probably don't like typing a lot of code. Wouldn't it be nice if you can compress multiple instructions into 1 line of code? Well, that's what functions are for! Functions let you run multiple instructions in one line, making your code look more organized and clean, and also making you type less code. Defining/Creating Functions In Luau, defining functions is quite simple. Just follow the template below: local function < function_name > () end Code inside the function is called the \u201cbody\u201d . The body of a function is executed when the function is called. To call a function, simply type its name followed by parentheses. Something like this: local function test_function () print ( \"Hello, friends!\" ) end test_function () -- ^ prints \"Hello, friends!\" Parameters & Arguments When defining functions, it's pretty common to have some parameters defined as well. You can think of parameters as variables exclusive to that function, a way to pass in some data that the function will use when it is called. -- this function has 1 parameter: \"name\" local function say_hello ( name ) print ( \"Hello \" .. name ) end say_hello ( \"big dude\" ) -- ^ prints \"Hello big dude\" Arguments are data that are passed when calling a function. In the example above, we passed \u201cbig dude\u201d when calling say_hello . Thus, we can say that \u201cbig dude\u201d is an argument. If you call a function with fewer arguments than it expects, those missing parameters will be nil . If you call a function with more arguments than it expects, it'll ignore those extra arguments. local function test_function ( parameter_1 , parameter_2 ) print ( parameter_1 , parameter_2 ) end test_function ( 1 ) -- fewer arguments -- ^ prints 1, nil test_function ( 1 , 2 , 3 , 4 ) -- too much arguments -- ^ prints 1, 2 Return Statements One of the most useful things a function can do is returning data back. Let's say you have a function called add_these_2_numbers_together (slick name, I know). As the name suggests, this function adds 2 numbers together and returns the result. local function add_these_2_numbers_together ( number_1 , number_2 ) end Now obviously we have to\u2026 well\u2026 add these 2 numbers together. local function add_these_2_numbers_together ( number_1 , number_2 ) local result = number_1 + number_2 end Now, with the hard part over, the last thing we need to do is return the result. We can do this using the conveniently named return keyword. local function add_these_2_numbers_together ( number_1 , number_2 ) local result = number_1 + number_2 return result end local sum = add_these_2_numbers_together ( 1 , 2 ) print ( sum ) -- ^ prints 3 (1 + 2 = 3) Functions can also return multiple values, simply separate the values you want to return with a comma , . local function add_and_sub ( number_1 , number_2 ) local sum = number_1 + number_2 local difference = number_1 - number_2 return sum , difference end local value1 , value2 = add_and_sub ( 3 , 2 ) print ( value1 ) -- ^ prints 5 (3 + 2 = 5) print ( value2 ) -- ^ prints 1 (3 - 2 = 1) REMEMBER! You cannot execute code below the return keyword because Luau expects an end after every return . Attempting to do so will result in an error. Challenges (Optional) Here's a challenge for ya! Make a function that adds, subtracts, and multiplies 2 numbers. Don't forget to return the results! local sum , difference , product = add_sub_mult ( 5 , 2 ) print ( sum ) -- ^ prints 7 (5 + 2 = 7) print ( difference ) -- ^ prints 3 (5 - 2 = 3) print ( product ) -- ^ prints 10 (5 * 2 = 10) Solution local function add_sub_mult ( number_1 , number_2 ) local sum = number_1 + number_2 local difference = number_1 - number_2 local product = number_1 * number_2 return sum , difference , product end Closing Thanks for reading! We hope you've learned a thing or two about functions and how to utilize 'em. Of course, we aren't perfect. We make mistakes, typos, etc. so if you found a mistake while reading this article, or any article for that matter, feel free to report it , and perhaps you can review us too! Any feedback is appreciated. Since this article only discussed the basics of functions, here are some resources that dive deeper into functions: Roblox's official documentation Lua PIL \u201cFunctions\u201d chapter","title":"Basics of Functions"},{"location":"Luau-Learning/Basics_of_Functions/#basics-of-functions","text":"I don't like typing a lot of code, YOU probably don't like typing a lot of code. Wouldn't it be nice if you can compress multiple instructions into 1 line of code? Well, that's what functions are for! Functions let you run multiple instructions in one line, making your code look more organized and clean, and also making you type less code.","title":"Basics of Functions"},{"location":"Luau-Learning/Basics_of_Functions/#definingcreating-functions","text":"In Luau, defining functions is quite simple. Just follow the template below: local function < function_name > () end Code inside the function is called the \u201cbody\u201d . The body of a function is executed when the function is called. To call a function, simply type its name followed by parentheses. Something like this: local function test_function () print ( \"Hello, friends!\" ) end test_function () -- ^ prints \"Hello, friends!\"","title":"Defining/Creating Functions"},{"location":"Luau-Learning/Basics_of_Functions/#parameters-arguments","text":"When defining functions, it's pretty common to have some parameters defined as well. You can think of parameters as variables exclusive to that function, a way to pass in some data that the function will use when it is called. -- this function has 1 parameter: \"name\" local function say_hello ( name ) print ( \"Hello \" .. name ) end say_hello ( \"big dude\" ) -- ^ prints \"Hello big dude\" Arguments are data that are passed when calling a function. In the example above, we passed \u201cbig dude\u201d when calling say_hello . Thus, we can say that \u201cbig dude\u201d is an argument. If you call a function with fewer arguments than it expects, those missing parameters will be nil . If you call a function with more arguments than it expects, it'll ignore those extra arguments. local function test_function ( parameter_1 , parameter_2 ) print ( parameter_1 , parameter_2 ) end test_function ( 1 ) -- fewer arguments -- ^ prints 1, nil test_function ( 1 , 2 , 3 , 4 ) -- too much arguments -- ^ prints 1, 2","title":"Parameters &amp; Arguments"},{"location":"Luau-Learning/Basics_of_Functions/#return-statements","text":"One of the most useful things a function can do is returning data back. Let's say you have a function called add_these_2_numbers_together (slick name, I know). As the name suggests, this function adds 2 numbers together and returns the result. local function add_these_2_numbers_together ( number_1 , number_2 ) end Now obviously we have to\u2026 well\u2026 add these 2 numbers together. local function add_these_2_numbers_together ( number_1 , number_2 ) local result = number_1 + number_2 end Now, with the hard part over, the last thing we need to do is return the result. We can do this using the conveniently named return keyword. local function add_these_2_numbers_together ( number_1 , number_2 ) local result = number_1 + number_2 return result end local sum = add_these_2_numbers_together ( 1 , 2 ) print ( sum ) -- ^ prints 3 (1 + 2 = 3) Functions can also return multiple values, simply separate the values you want to return with a comma , . local function add_and_sub ( number_1 , number_2 ) local sum = number_1 + number_2 local difference = number_1 - number_2 return sum , difference end local value1 , value2 = add_and_sub ( 3 , 2 ) print ( value1 ) -- ^ prints 5 (3 + 2 = 5) print ( value2 ) -- ^ prints 1 (3 - 2 = 1) REMEMBER! You cannot execute code below the return keyword because Luau expects an end after every return . Attempting to do so will result in an error.","title":"Return Statements"},{"location":"Luau-Learning/Basics_of_Functions/#challenges-optional","text":"Here's a challenge for ya! Make a function that adds, subtracts, and multiplies 2 numbers. Don't forget to return the results! local sum , difference , product = add_sub_mult ( 5 , 2 ) print ( sum ) -- ^ prints 7 (5 + 2 = 7) print ( difference ) -- ^ prints 3 (5 - 2 = 3) print ( product ) -- ^ prints 10 (5 * 2 = 10) Solution local function add_sub_mult ( number_1 , number_2 ) local sum = number_1 + number_2 local difference = number_1 - number_2 local product = number_1 * number_2 return sum , difference , product end","title":"Challenges (Optional)"},{"location":"Luau-Learning/Basics_of_Functions/#closing","text":"Thanks for reading! We hope you've learned a thing or two about functions and how to utilize 'em. Of course, we aren't perfect. We make mistakes, typos, etc. so if you found a mistake while reading this article, or any article for that matter, feel free to report it , and perhaps you can review us too! Any feedback is appreciated. Since this article only discussed the basics of functions, here are some resources that dive deeper into functions: Roblox's official documentation Lua PIL \u201cFunctions\u201d chapter","title":"Closing"},{"location":"Luau-Learning/Bindable_events_and_functions/","text":"Bindable Events and Functions Bindable events and functions are pretty much similar to Remote Events and Functions . However, In this guide, we will explain bindable events and functions from scratch. Basic Info Bindable events or functions are used for communication between server-side Script(s) . Bindable events offer one-way communication. However bindable functions are capable of performing two-way communication. This doesn't mean that bindable functions are anyway better than bindable events. They should be according to their use cases. Bindable Events Using bindable events, an event can be fired from one script and can be received on another script. How to use bindable events? First of all, add a bindable event in ServerStorage By default its name is \"Event\" but I have changed its name to \"BindableEvent\" just to make it easier to understand. Now we will add two Script(s) in ServerScriptService . Name one of them \"Sender\" and the other \"Receiver\". We will use \"Sender\" for firing the event and \"Receiver\" for receiving that event. For firing a bindable event, we will use a method BindableEvent:Fire() . BindableEvent.Event will be used for receiving events. Let's implement this! Code on \"Sender\": game . ServerStorage . BindableEvent : Fire ( \"eden is cool\" ) Any number of arguments can be passed when firing an event. Code on \"Receiver\": game . ServerStorage . BindableEvent . Event : Connect ( function ( value ) print ( value ) --eden is cool print ( \"event recieved\" ) end ) Yep, it's that easy and simple. Now when you run the game and as the event is received. You can see \"event received\" in the output window. Bindable Functions For bindable functions, we will use the same setup for script and place the bindable function in ServerStorage() . The explorer tree will look like, As done earlier, we will use \"Sender\" for invoking the bindable function and \"Receiver\" for binding a function to the bindable function. For doing so, we will be using BindableFunction:Invoke and BindableFunction.OnInvoke . Code on \"Sender\": game . ServerStorage . BindableFunction : Invoke ( \"eden is cool\" ) Code on \"Receiver\": game . ServerStorage . BindableFunction . OnInvoke = function ( value ) print ( value ) --eden is cool print ( \"function invoked\" ) return true end Drawbacks Once invoked the bindable function, the thread will yield until any callback is found. If the callback isn't set, the thread will yield forever. In bindable events, you can create multiple connections on the event but you can not bind multiple functions to BindableFunction:Invoke Closing! I hope, you enjoyed read it! If you find any typos, or any sort of flaws then please report it here .","title":"Bindable Events and Functions"},{"location":"Luau-Learning/Bindable_events_and_functions/#bindable-events-and-functions","text":"Bindable events and functions are pretty much similar to Remote Events and Functions . However, In this guide, we will explain bindable events and functions from scratch.","title":"Bindable Events and Functions"},{"location":"Luau-Learning/Bindable_events_and_functions/#basic-info","text":"Bindable events or functions are used for communication between server-side Script(s) . Bindable events offer one-way communication. However bindable functions are capable of performing two-way communication. This doesn't mean that bindable functions are anyway better than bindable events. They should be according to their use cases.","title":"Basic Info"},{"location":"Luau-Learning/Bindable_events_and_functions/#bindable-events","text":"Using bindable events, an event can be fired from one script and can be received on another script.","title":"Bindable Events"},{"location":"Luau-Learning/Bindable_events_and_functions/#how-to-use-bindable-events","text":"First of all, add a bindable event in ServerStorage By default its name is \"Event\" but I have changed its name to \"BindableEvent\" just to make it easier to understand. Now we will add two Script(s) in ServerScriptService . Name one of them \"Sender\" and the other \"Receiver\". We will use \"Sender\" for firing the event and \"Receiver\" for receiving that event. For firing a bindable event, we will use a method BindableEvent:Fire() . BindableEvent.Event will be used for receiving events. Let's implement this! Code on \"Sender\": game . ServerStorage . BindableEvent : Fire ( \"eden is cool\" ) Any number of arguments can be passed when firing an event. Code on \"Receiver\": game . ServerStorage . BindableEvent . Event : Connect ( function ( value ) print ( value ) --eden is cool print ( \"event recieved\" ) end ) Yep, it's that easy and simple. Now when you run the game and as the event is received. You can see \"event received\" in the output window.","title":"How to use bindable events?"},{"location":"Luau-Learning/Bindable_events_and_functions/#bindable-functions","text":"For bindable functions, we will use the same setup for script and place the bindable function in ServerStorage() . The explorer tree will look like, As done earlier, we will use \"Sender\" for invoking the bindable function and \"Receiver\" for binding a function to the bindable function. For doing so, we will be using BindableFunction:Invoke and BindableFunction.OnInvoke . Code on \"Sender\": game . ServerStorage . BindableFunction : Invoke ( \"eden is cool\" ) Code on \"Receiver\": game . ServerStorage . BindableFunction . OnInvoke = function ( value ) print ( value ) --eden is cool print ( \"function invoked\" ) return true end","title":"Bindable Functions"},{"location":"Luau-Learning/Bindable_events_and_functions/#drawbacks","text":"Once invoked the bindable function, the thread will yield until any callback is found. If the callback isn't set, the thread will yield forever. In bindable events, you can create multiple connections on the event but you can not bind multiple functions to BindableFunction:Invoke","title":"Drawbacks"},{"location":"Luau-Learning/Bindable_events_and_functions/#closing","text":"I hope, you enjoyed read it! If you find any typos, or any sort of flaws then please report it here .","title":"Closing!"},{"location":"Luau-Learning/Character/","text":"Character The Character is the physical 3d model of your Player . How Do You Access The Character Depending if you're on the Client/Server the character can be accessed in two different ways. Client: local Players = game : GetService ( 'Players' ) local Player = Players . LocalPlayer local Character = Player . Character or Player . CharacterAdded : Wait () print ( Character . Name ) -- TheSalzu Just to clear up some confusion, the reason we do Player.CharacterAdded:Wait() is because the player's character may not have fully loaded in yet. If you're also confused about the Players service refer to Players Now if you're on the server this is a way you can access the character local Players = game : GetService ( 'Players' ) Players . PlayerAdded : Connect ( function ( Player ) Player . CharacterAdded : Connect ( function ( Character ) print ( Character . Name ) -- TheSalzu end ) end ) Now, this isn't how you're always going to access a Character, they're plenty of ways to get the character. More Ways To Access The Character If you're using a tool and want to get the Character then you can do local Tool = ToolInstance Tool . Activated : Connect ( function () local Character = Tool . Parent -- Tools always get parented to the Character print ( Character . Name ) -- TheSalzu end ) A general way to get the character is by checking if it has a HumanoidRootPart. For this, we'll be using a part getting touched. local Part = workspace . Part -- Example Part . Touched : Connect ( function ( PartThatGotTouched ) local HumanoidRootPart = Part . Parent : FindFirstChild ( 'HumanoidRootPart' ) if HumanoidRootPart then print ( 'We found a character!' ) end end ) One last thing that isn't really related to getting the character but is still useful is, getting the player from the character. local Players = game : GetService ( 'Players' ) local Player = Players : GetPlayerFromCharacter ( CharacterModel ) print ( Player ) -- TheSalzu Humanoid The Humanoid is what gives the Character model functionality. It lets the Character move, jump, and interact. The humanoid will always be parented under the character and it has to be named \"Humanoid\". If it isn't named Humanoid then your reset button will not work. Cool things you can do with the humanoid: As you can see from the image above, the humanoid has a lot of things you can do with it. I will list some here. local Humanoid = Character . Humanoid Humanoid . Health = 1000 Humanoid . MaxHealth = 1000 Humanoid . JumpPower = 100 Humanoid . WalkSpeed = 60 Humanoid . AutoJumpEnabled = true / false -- On mobile when you hit an obstacle it will auto jump Humanoid . DisplayName = 'String' These are the fun ones that you can mess with but now I'll talk about some useful methods the Humanoid has. These are not all of the methods the humanoid has! local Humanoid = Character . Humanoid Humanoid : EquipTool ( ToolInstance ) Humanoid : UnEquipTools () Humanoid : TakeDamage ( Number ) Humanoid : AddAccessory ( AccessoryInstance ) Humanoid : ChangeState ( Enum . State . YourState ) --Walking,Running,Ragdoll,Sitting,Jumping Humanoid : GetAccessories () -- Returns an array of all of the accessories Humanoid : GetState () -- Returns the current state Humanoid : PlayEmote ( 'EmoteName' ) Now we can talk about some useful events the humanoid has local Humanoid = Character . Humanoid Humanoid . Died : Connect ( function () print ( 'The humanoid has died!' ) end ) Humanoid . HealthChanged : Connect ( function ( Health ) print ( 'The health has changed!' ) end ) Humanoid . StateChanged : Connect ( function ( State ) print ( State ) end ) -- Here are some state changes, for these, I will not be doing the full event with the end) Humanoid . Jumping : Connect ( function ()) Humanoid . Running : Connect ( function ()) Humanoid . Swimming : Connect ( function ()) Humanoid . Seated : Connect ( function ()) Humanoid . Ragdoll : Connect ( function ()) Humanoid . FreeFalling : Connect ( function ()) That's all for the Humanoid. If you want to know more go take a good read at: Humanoid API How To Move A Character Moving a character is quite simple. All you have to do is simply change their Pivot via CFrame. local Character -- Your method of getting the Character Character : PivotTo ( CFrameValue ) For more information on CFrame go take a read at: Roblox's official guide on CFrame Closing! That's pretty much of it. Hope you enjoyed reading it. In case of any mistake, typos, etc. Please report the article. You can also give us reviews here","title":"Character"},{"location":"Luau-Learning/Character/#character","text":"The Character is the physical 3d model of your Player .","title":"Character"},{"location":"Luau-Learning/Character/#how-do-you-access-the-character","text":"Depending if you're on the Client/Server the character can be accessed in two different ways. Client: local Players = game : GetService ( 'Players' ) local Player = Players . LocalPlayer local Character = Player . Character or Player . CharacterAdded : Wait () print ( Character . Name ) -- TheSalzu Just to clear up some confusion, the reason we do Player.CharacterAdded:Wait() is because the player's character may not have fully loaded in yet. If you're also confused about the Players service refer to Players Now if you're on the server this is a way you can access the character local Players = game : GetService ( 'Players' ) Players . PlayerAdded : Connect ( function ( Player ) Player . CharacterAdded : Connect ( function ( Character ) print ( Character . Name ) -- TheSalzu end ) end ) Now, this isn't how you're always going to access a Character, they're plenty of ways to get the character.","title":"How Do You Access The Character"},{"location":"Luau-Learning/Character/#more-ways-to-access-the-character","text":"If you're using a tool and want to get the Character then you can do local Tool = ToolInstance Tool . Activated : Connect ( function () local Character = Tool . Parent -- Tools always get parented to the Character print ( Character . Name ) -- TheSalzu end ) A general way to get the character is by checking if it has a HumanoidRootPart. For this, we'll be using a part getting touched. local Part = workspace . Part -- Example Part . Touched : Connect ( function ( PartThatGotTouched ) local HumanoidRootPart = Part . Parent : FindFirstChild ( 'HumanoidRootPart' ) if HumanoidRootPart then print ( 'We found a character!' ) end end ) One last thing that isn't really related to getting the character but is still useful is, getting the player from the character. local Players = game : GetService ( 'Players' ) local Player = Players : GetPlayerFromCharacter ( CharacterModel ) print ( Player ) -- TheSalzu","title":"More Ways To Access The Character"},{"location":"Luau-Learning/Character/#humanoid","text":"The Humanoid is what gives the Character model functionality. It lets the Character move, jump, and interact. The humanoid will always be parented under the character and it has to be named \"Humanoid\". If it isn't named Humanoid then your reset button will not work. Cool things you can do with the humanoid: As you can see from the image above, the humanoid has a lot of things you can do with it. I will list some here. local Humanoid = Character . Humanoid Humanoid . Health = 1000 Humanoid . MaxHealth = 1000 Humanoid . JumpPower = 100 Humanoid . WalkSpeed = 60 Humanoid . AutoJumpEnabled = true / false -- On mobile when you hit an obstacle it will auto jump Humanoid . DisplayName = 'String' These are the fun ones that you can mess with but now I'll talk about some useful methods the Humanoid has. These are not all of the methods the humanoid has! local Humanoid = Character . Humanoid Humanoid : EquipTool ( ToolInstance ) Humanoid : UnEquipTools () Humanoid : TakeDamage ( Number ) Humanoid : AddAccessory ( AccessoryInstance ) Humanoid : ChangeState ( Enum . State . YourState ) --Walking,Running,Ragdoll,Sitting,Jumping Humanoid : GetAccessories () -- Returns an array of all of the accessories Humanoid : GetState () -- Returns the current state Humanoid : PlayEmote ( 'EmoteName' ) Now we can talk about some useful events the humanoid has local Humanoid = Character . Humanoid Humanoid . Died : Connect ( function () print ( 'The humanoid has died!' ) end ) Humanoid . HealthChanged : Connect ( function ( Health ) print ( 'The health has changed!' ) end ) Humanoid . StateChanged : Connect ( function ( State ) print ( State ) end ) -- Here are some state changes, for these, I will not be doing the full event with the end) Humanoid . Jumping : Connect ( function ()) Humanoid . Running : Connect ( function ()) Humanoid . Swimming : Connect ( function ()) Humanoid . Seated : Connect ( function ()) Humanoid . Ragdoll : Connect ( function ()) Humanoid . FreeFalling : Connect ( function ()) That's all for the Humanoid. If you want to know more go take a good read at: Humanoid API","title":"Humanoid"},{"location":"Luau-Learning/Character/#how-to-move-a-character","text":"Moving a character is quite simple. All you have to do is simply change their Pivot via CFrame. local Character -- Your method of getting the Character Character : PivotTo ( CFrameValue ) For more information on CFrame go take a read at: Roblox's official guide on CFrame","title":"How To Move A Character"},{"location":"Luau-Learning/Character/#closing","text":"That's pretty much of it. Hope you enjoyed reading it. In case of any mistake, typos, etc. Please report the article. You can also give us reviews here","title":"Closing!"},{"location":"Luau-Learning/ContextActionService/","text":"Context Action Service Context action is a service that helps in binding actions to inputs. It is similar to UserInputService but has some cooler features. Understanding Use Case Context action service works according to its name. It enables you to bind and unbind actions on input based on conditions. Its use case can be easily understood by the following examples. A player may open a door only when he is closer to it. A player may interact with an NPC only when they are inside the shop. Using context action service, you will bind an action when the player is closer to the door. As the player moves away from the door, you should unbind the action. Viewing Bound Actions In order to view the bound actions, open the console (either using the main menu or the F9 key). Visit the \" Action Bindings \" tab. It will display all the bound actions. These also include actions bound by Roblox core scripts. Action Priorities Via context action service, you can bind multiple actions to an input. However, those actions will be performed based on different priorities. The most recent bound action will have the highest priority. These priorities can be changed using BindActionPeriority . Multiple Medium Input Detection ContextActionService also supports gamepads, and touch screens. Using contextactionservice, you can create on-screen touch buttons. These buttons are rendered as long as the action is bound. These buttons can be customized by changing their positions, and labels. Usage In this guide, we will cover some basic fundamental functions of ContextActionService. Binding Actions For binding an action we use the method :BindAction() . This function takes four arguments Name of Action | type: String Function handling the action | type: Function Condition for creating touch button | type: Bool InputObject | KeyCode or UserInputType Name Of Action The name of action can be any suitable string that represents the action. Function Handling The Action This function will be called whenever the input key (to which action is bound) is pressed. This function is called with the following parameters Name of action that was originally given when binding action. | type: String State of the input (These include Begin, Change, End, or Cancel). | type: UserInputState An object containing information about the input. | type: InputObject Example function: local function Action_Handler ( ActionName , InputState , InputObject ) if InputState == Enum . UserInputState . Begin then print ( \"Teerach is an English geek\" ) else print ( \"Paper was made of China!\" ) end end Mobile Button The third argument of BindAction() is a bool value. To enable the mobile button, this argument should be true or otherwise false . Input type Basically the Enums of key codes or user input types. local ContextActionService = game : GetService ( \"ContextActionService\" ) local function Action_Handler ( ActionName , InputState , InputObject ) if InputState == Enum . UserInputState . Begin then print ( \"EdenRose is blessing the world with her present\" ) else print ( \"Thanks to helper department for such an impressive documentation\" ) end end ContextActionService : BindAction ( \"Input Detection\" , Action_Handler , true , Enum . KeyCode . P ) Now, we have bound the action Input Detection with the key \"P\" Unbinding Actions Once bound, you can unbind an action when you are done with it. This can be done using :UnbindAction() . This method takes the name of the bound action. ContextActionService : UnbindAction ( \"Input Detection\" ) Closing! That's pretty much all of it. I hope you enjoyed reading it and now have a basic understanding of ContextActionService. In case of any mistakes, typos, etc. Please report the article. You can also give us reviews here","title":"Context Action Service"},{"location":"Luau-Learning/ContextActionService/#context-action-service","text":"Context action is a service that helps in binding actions to inputs. It is similar to UserInputService but has some cooler features.","title":"Context Action Service"},{"location":"Luau-Learning/ContextActionService/#understanding-use-case","text":"Context action service works according to its name. It enables you to bind and unbind actions on input based on conditions. Its use case can be easily understood by the following examples. A player may open a door only when he is closer to it. A player may interact with an NPC only when they are inside the shop. Using context action service, you will bind an action when the player is closer to the door. As the player moves away from the door, you should unbind the action.","title":"Understanding Use Case"},{"location":"Luau-Learning/ContextActionService/#viewing-bound-actions","text":"In order to view the bound actions, open the console (either using the main menu or the F9 key). Visit the \" Action Bindings \" tab. It will display all the bound actions. These also include actions bound by Roblox core scripts.","title":"Viewing Bound Actions"},{"location":"Luau-Learning/ContextActionService/#action-priorities","text":"Via context action service, you can bind multiple actions to an input. However, those actions will be performed based on different priorities. The most recent bound action will have the highest priority. These priorities can be changed using BindActionPeriority .","title":"Action Priorities"},{"location":"Luau-Learning/ContextActionService/#multiple-medium-input-detection","text":"ContextActionService also supports gamepads, and touch screens. Using contextactionservice, you can create on-screen touch buttons. These buttons are rendered as long as the action is bound. These buttons can be customized by changing their positions, and labels.","title":"Multiple Medium Input Detection"},{"location":"Luau-Learning/ContextActionService/#usage","text":"In this guide, we will cover some basic fundamental functions of ContextActionService.","title":"Usage"},{"location":"Luau-Learning/ContextActionService/#binding-actions","text":"For binding an action we use the method :BindAction() . This function takes four arguments Name of Action | type: String Function handling the action | type: Function Condition for creating touch button | type: Bool InputObject | KeyCode or UserInputType","title":"Binding Actions"},{"location":"Luau-Learning/ContextActionService/#name-of-action","text":"The name of action can be any suitable string that represents the action.","title":"Name Of Action"},{"location":"Luau-Learning/ContextActionService/#function-handling-the-action","text":"This function will be called whenever the input key (to which action is bound) is pressed. This function is called with the following parameters Name of action that was originally given when binding action. | type: String State of the input (These include Begin, Change, End, or Cancel). | type: UserInputState An object containing information about the input. | type: InputObject Example function: local function Action_Handler ( ActionName , InputState , InputObject ) if InputState == Enum . UserInputState . Begin then print ( \"Teerach is an English geek\" ) else print ( \"Paper was made of China!\" ) end end","title":"Function Handling The Action"},{"location":"Luau-Learning/ContextActionService/#mobile-button","text":"The third argument of BindAction() is a bool value. To enable the mobile button, this argument should be true or otherwise false .","title":"Mobile Button"},{"location":"Luau-Learning/ContextActionService/#input-type","text":"Basically the Enums of key codes or user input types. local ContextActionService = game : GetService ( \"ContextActionService\" ) local function Action_Handler ( ActionName , InputState , InputObject ) if InputState == Enum . UserInputState . Begin then print ( \"EdenRose is blessing the world with her present\" ) else print ( \"Thanks to helper department for such an impressive documentation\" ) end end ContextActionService : BindAction ( \"Input Detection\" , Action_Handler , true , Enum . KeyCode . P ) Now, we have bound the action Input Detection with the key \"P\"","title":"Input type"},{"location":"Luau-Learning/ContextActionService/#unbinding-actions","text":"Once bound, you can unbind an action when you are done with it. This can be done using :UnbindAction() . This method takes the name of the bound action. ContextActionService : UnbindAction ( \"Input Detection\" )","title":"Unbinding Actions"},{"location":"Luau-Learning/ContextActionService/#closing","text":"That's pretty much all of it. I hope you enjoyed reading it and now have a basic understanding of ContextActionService. In case of any mistakes, typos, etc. Please report the article. You can also give us reviews here","title":"Closing!"},{"location":"Luau-Learning/HttpService/","text":"HttpService This article will teach you the fundamentals of the HttpService . At the end of this article, you will know what HttpService is, what it is used for and how to use it. What is HttpService? HttpService is a built-in API Service, allowing developers to send Http requests to web servers other than Roblox. Basically, it helps you interact with the internet outside Roblox. What can HttpService used for? As mentioned above, HttpService can help you do basic communications between your Roblox game/experience and off-site web services. Some of those being: Data storage (though can be done with DataStoreService) Error reporting Feedback system Real-time communication Other fun API stuff What can't be HttpService used for? Interact with internal Roblox APIs or any Roblox websites. Interact with services that are blocked by Roblox. Create/host a web server Hence, this service can not respond to any HTTP requests. URL embedding (e.g. use an image URL as an UI element, or play a YouTube URL). Next, you will learn how to use HttpService. How does it work? Yes, you will need to know how it works before you actually use it. Imagine 2 people, \"Steve\" and \"Alex\" respectively, communicating with each other. Steve wanted to know how Alex is doing, so he decided to ask her. Now Steve can just come to Alex and ask her how her day's going, but she is away from her home right now. Steve decided to text Alex instead, then after a while, he received a text from Alex, saying that she is visiting her grandma and will return tomorrow. In this story, Steve is communicating with Alex through texting. Steve sent a question, wanting to know where Alex was and Alex responded with her being at her grandpa's house and she would return by tomorrow. HttpService works the same way. HttpService communicate with outer servers using the JSON format (not regular text!). In order to get information from server X, HttpService send a HTTP request to request data from X (through a method which we will cover in the next part). X will then respond with a data (also in JSON format) that satisfy the required information from HttpService. What does JSON looks like? JSON is simply a list of key-value pairs. The key is a string in \"\" and the value can be in number, boolean, array, list, etc.Each pairs is seperated with a comma. JSON data can be stored in a file with .json extension, and can be opened with a web browser like Chrome or Firefox. Most web server communications are done through JSON format. { \"key\" : \"value\" , \"number\" : 2 , \"array\" : [ { \"value1\" : true }, { \"value2\" : 2 } ], \"list\" : { { \"list_a\" : \"comg\" } } \"null\" : null } How do I use the HttpService? Step 0: Enabling the service HttpService is off by default. To start playing around, you will need to turn it on. There are 2 ways to do so: Go to Game Settings -> Security -> Turn on Allow HTTP Requests -> Click Save Within the Command Bar , run the following command: game : GetService ( \"HttpService\" ). HttpEnabled = true Note When your game has yet to be published, the second method is the only option. To turn the service off, simply change from true to false, then run the command again. Enabling the service won't heavily damage the in-game security, but make sure to have anti-exploit methods for your game! Then we start coding It's best to explain with an example. In this article, we will try to get the amount of online players within the Hypixel Minecraft Server . This should be interesting enough. You will use these 2 methods in this example: HttpService:GetAsync(url, nocache, headers) HttpService:JSONDecode(input) Let's do some communication, like Steve and Alex. 1. GetAsync In order to know how many players there are in Hypixel, we will request data from that server. GetAsync performs a \"Get\" request (commonly written as GET) to the target server and get the target information. You can understand \"Async\" as \"waiting\", because we don't know when the server will respond. It could be instantly, or 1 second, sometimes 10 seconds. GetAsync will yield the script until a respond is given. 1.1. Indicating the target URL GetAsync consists of 3 parameters. We will only use the first one, the url endpoint parameter. Now, we need to determine the endpoint URL. An endpoint URL is basically where the information is shown , and in this example I will use the following URL: * https://api.mcsrvstat.us/2/mc.hypixel.net 1.2. Find the information When you open the URL, you will see a very long and confusing text (unless you're using Firefox, they have a very nice viewer for JSON). This is the JSON that is containing information regarding Hypixel. Now, our initial goal is to find the amount of online players . You might have a hard time finding it so I'll do the hard job for you (just this once alright). Attention This line indicates that there are, as of the time this image is taken, 40737 online players. Keep in mind that this number is NOT constant because players join and leave every moment. These kind of results are expected to change all the time. 1.3. Coding Now we know where is the information to get, time to open Roblox Studio. HttpService requests should always be handled within a Script under ServerScriptService . Create one by right clicking the \"ServerScriptService\" -> Insert Object... -> Script . Name the script however you want! Now, take a close look at the following script. Each comment will help you understand each line of code. Code Output -- Get the HttpService through the GetService() method local HttpService = game : GetService ( \"HttpService\" ) -- Declare the target URL -- URL must be put inside quotes. If there're quotes within the URL, use \\ to escape it local URL = \"https://api.mcsrvstat.us/2/mc.hypixel.net\" -- As mentioned, GetAsync will return the information so we have to put it into a variable local info = HttpService : GetAsync ( URL ) -- Print the information into the Output window -- If you can't see the Output, go to View -> Output print ( info ) { \"ip\" : \"172.65.230.166\" , \"port\" : 25565 , \"debug\" :{ \"ping\" : true , \"query\" : false , \"srv\" : false , \"querymismatch\" : false , \"ipinsrv\" : false , \"cnameinsrv\" : false , \"animatedmotd\" : false , \"cachetime\" : 1657866731 , \"apiversion\" : 2 }, \"motd\" :{ \"raw\" :[ \" \\u00a7aHypixel Network \\u00a7c[1.8-1.19]\" , \" \\u00a76\\u00a7lSUMMER EVENT \\u00a77- \\u00a7e\\u00a7lLEVEL UP, NEW COSMETICS\" ], \"clean\" :[ \" Hypixel Network [1.8-1.19]\" , \" SUMMER EVENT - LEVEL UP, NEW COSMETICS\" ], \"html\" :[ \" <span style=\\\"color: #55FF55\\\">Hypixel Network <\\/span><span style=\\\"color: #FF5555\\\">[1.8-1.19]<\\/span>\" , \" <span style=\\\"color: #FFAA00\\\"><span style=\\\"font-weight: bold;\\\">SUMMER EVENT <\\/span><\\/span><span style=\\\"color: #AAAAAA\\\">- <\\/span><span style=\\\"color: #FFFF55\\\"><span style=\\\"font-weight: bold;\\\">LEVEL UP, NEW COSMETICS<\\/span><\\/span>\" ]}, \"players\" :{ \"online\" : 39948 , \"max\" : 200000 }, ..... Now the output will look the same as the JSON screen when we open the URL. But we haven't done yet. 2. JSONDecode Luau (the programming language that Roblox uses) by itself can NOT handle JSON format. The output you're looking at is a string version of the raw JSON data, and it is a nightmare to work with. Thankfully though, HttpService has another method that can help us turning a JSON mess into something we can code with, the JSONDecode method. Note JSONDecode can be used whether or not the HttpService is enabled. So far, our code look like this (without the comments): local HttpService = game : GetService ( \"HttpService\" ) local URL = \"https://api.mcsrvstat.us/2/mc.hypixel.net\" local info = HttpService : GetAsync ( URL ) -- Raw JSON print ( info ) info right now is a string version of the raw JSON information. JSONDecode will turn it into a dictionary . JSONDecode has only one parameter, the raw JSON respond returned by GetAsync . Wait, why dictionary? JSON and Luau's dictionary share the same key-value pairs behavior, so the engine can easily \"decode\" it. After decoding, we can start indexing the information like how we did normally. JSON { \"key\" : \"value\" } Luau local dict = { key = \"value\" -- or [\"key\"] = \"value\" } print ( dict . key ) --> value The method is simple: Script Output local HttpService = game : GetService ( \"HttpService\" ) local URL = \"https://api.mcsrvstat.us/2/mc.hypixel.net\" local info = HttpService : GetAsync ( URL ) -- Raw JSON local info_dict = HttpService : JSONDecode ( info ) -- Decoded JSON print ( info_dict ) -- Print the info Note: I've cut off some of the output to keep this screen short. Your output will be filled with a alot of bizzare base64 code, but the format will be the same! Within your output, click the arrow \"\u25b6\" to expand a table that looks like {...} . { [ \"debug\" ] = \u25b6 {...}, [ \"hostname\" ] = \"mc.hypixel.net\" , [ \"icon\" ] = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAA......zrDmHEPQgkAAAAASUVORK5CYII=\" , [ \"ip\" ] = \"172.65.236.36\" , [ \"motd\" ] = \u25b6 {...}, [ \"online\" ] = true , [ \"players\" ] = \u25bc { [ \"max\" ] = 200000 , [ \"online\" ] = 39694 }, [ \"port\" ] = 25565 , [ \"protocol\" ] = 47 , [ \"version\" ] = \"Requires MC 1.8 / 1.19\" } Hey look, it's the players information we're looking for! The amount of players have changed , but we have talked this through. Great, we now have a scriptable data table, all we have to do now is indexing the data . local HttpService = game : GetService ( \"HttpService\" ) local URL = \"https://api.mcsrvstat.us/2/mc.hypixel.net\" local info = HttpService : GetAsync ( URL ) local info_dict = HttpService : JSONDecode ( info ) local online_players = info_dict . players . online -- indexing the key print ( \"There are \" .. online_players .. \" players in Hypixel.\" ) Take a look at your output, you will see a line like There are 32093 players in Hypixel . Of course, this number is not constant, but if you do see one, that means the request has successfully been done and you have a basic idea of know how to use GetAsync and JSONDecode ! *. Improvements While the URL I picked for you is relatively stable and accurate and the Hypixel server is likely never go offline, sometimes maintenance or sudden outage can occur, and either one of them will be down. This cause 2 problems to appear: * The endpoint URL is inaccessible, making the HttpService errored. * The request return an error (caused by the offline Hypixel server), making the HttpService errored. These are of course not the only problems that might appear during a request. So we will need a proper method to handle such occasions. This is where pcall() comes to handy. pcall() , or p rotected call , is used when a function might fail. pcall() return 2 values: success and a value returned by the function. We will protect our request like so: local HttpService = game : GetService ( \"HttpService\" ) local URL = \"https://api.mcsrvstat.us/2/mc.hypixel.net\" local success , info = pcall ( function () local raw_info = HttpService : GetAsync ( URL ) local info_dict = HttpService : JSONDecode ( raw_info ) return info_dict -- the \"info\" variable will be the \"info_dict\" we returned. end ) if success then -- success is a boolean value, it should be self-explanatory. local online_players = info_dict . players . online print ( \"There are \" .. online_players .. \" players in Hypixel.\" ) else warn ( 'Error occurred! ' .. info ) -- This \"info\" variable will handle our error messages. You can start your debugging process based on this. end 3. PostAsync PostAsync is a method that \"post\" data to a specified web server (this is commonly written as \"POST requests\") and handle results that returned by said server. However, PostAsync can not be replaced by GetAsync and vice versa . This is because some web servers are designated to handle GET or POST requests only. PostAsync has 5 parameters, the first 2 are mandatory : * The target url endpoint. * The data to be sent to the target. PostAsync can be used to make, for example, a feedback system in Roblox, where players send feedback to the feedback section and developers will based on that to improve the game. 4. JSONEncode As the name suggest, JSONEncode do the exact opposite of what JSONDecode do: convert a dictionary table to a JSON string . This raw JSON can be used as the data argument for the PostAsync method. Note JSONEncode can be used whether or not the HttpService is enabled. JSONEncode has only one parameter, a dictionary table. Here's a quick code example: Script Output local HttpService = game : GetService ( \"HttpService\" ) local info = { feedback = \"This game is epic\" , rate = 9 , player = \"shogi\" } local json = HttpService : JSONEncode ( info ) -- Raw JSON in string type print ( json ) { \"feedback\" : \"This game is epic\" , \"player\" : \"shogi\" , \"rate\" : 9 } Note If one of the value in the dictionary is nil , that key-value pair will be ignored. That means it will not be translated to JSON null value. Additional links Official Roblox HttpService documentation More about HTTP Requests More about the JSON format That's about it I hope you can use the service to improve your game experience. Good luck bai","title":"HttpService"},{"location":"Luau-Learning/HttpService/#httpservice","text":"This article will teach you the fundamentals of the HttpService . At the end of this article, you will know what HttpService is, what it is used for and how to use it.","title":"HttpService"},{"location":"Luau-Learning/HttpService/#what-is-httpservice","text":"HttpService is a built-in API Service, allowing developers to send Http requests to web servers other than Roblox. Basically, it helps you interact with the internet outside Roblox.","title":"What is HttpService?"},{"location":"Luau-Learning/HttpService/#what-can-httpservice-used-for","text":"As mentioned above, HttpService can help you do basic communications between your Roblox game/experience and off-site web services. Some of those being: Data storage (though can be done with DataStoreService) Error reporting Feedback system Real-time communication Other fun API stuff","title":"What can HttpService used for?"},{"location":"Luau-Learning/HttpService/#what-cant-be-httpservice-used-for","text":"Interact with internal Roblox APIs or any Roblox websites. Interact with services that are blocked by Roblox. Create/host a web server Hence, this service can not respond to any HTTP requests. URL embedding (e.g. use an image URL as an UI element, or play a YouTube URL). Next, you will learn how to use HttpService.","title":"What can't be HttpService used for?"},{"location":"Luau-Learning/HttpService/#how-does-it-work","text":"Yes, you will need to know how it works before you actually use it. Imagine 2 people, \"Steve\" and \"Alex\" respectively, communicating with each other. Steve wanted to know how Alex is doing, so he decided to ask her. Now Steve can just come to Alex and ask her how her day's going, but she is away from her home right now. Steve decided to text Alex instead, then after a while, he received a text from Alex, saying that she is visiting her grandma and will return tomorrow. In this story, Steve is communicating with Alex through texting. Steve sent a question, wanting to know where Alex was and Alex responded with her being at her grandpa's house and she would return by tomorrow. HttpService works the same way. HttpService communicate with outer servers using the JSON format (not regular text!). In order to get information from server X, HttpService send a HTTP request to request data from X (through a method which we will cover in the next part). X will then respond with a data (also in JSON format) that satisfy the required information from HttpService. What does JSON looks like? JSON is simply a list of key-value pairs. The key is a string in \"\" and the value can be in number, boolean, array, list, etc.Each pairs is seperated with a comma. JSON data can be stored in a file with .json extension, and can be opened with a web browser like Chrome or Firefox. Most web server communications are done through JSON format. { \"key\" : \"value\" , \"number\" : 2 , \"array\" : [ { \"value1\" : true }, { \"value2\" : 2 } ], \"list\" : { { \"list_a\" : \"comg\" } } \"null\" : null }","title":"How does it work?"},{"location":"Luau-Learning/HttpService/#how-do-i-use-the-httpservice","text":"","title":"How do I use the HttpService?"},{"location":"Luau-Learning/HttpService/#step-0-enabling-the-service","text":"HttpService is off by default. To start playing around, you will need to turn it on. There are 2 ways to do so: Go to Game Settings -> Security -> Turn on Allow HTTP Requests -> Click Save Within the Command Bar , run the following command: game : GetService ( \"HttpService\" ). HttpEnabled = true Note When your game has yet to be published, the second method is the only option. To turn the service off, simply change from true to false, then run the command again. Enabling the service won't heavily damage the in-game security, but make sure to have anti-exploit methods for your game!","title":"Step 0: Enabling the service"},{"location":"Luau-Learning/HttpService/#then-we-start-coding","text":"It's best to explain with an example. In this article, we will try to get the amount of online players within the Hypixel Minecraft Server . This should be interesting enough. You will use these 2 methods in this example: HttpService:GetAsync(url, nocache, headers) HttpService:JSONDecode(input) Let's do some communication, like Steve and Alex.","title":"Then we start coding"},{"location":"Luau-Learning/HttpService/#1-getasync","text":"In order to know how many players there are in Hypixel, we will request data from that server. GetAsync performs a \"Get\" request (commonly written as GET) to the target server and get the target information. You can understand \"Async\" as \"waiting\", because we don't know when the server will respond. It could be instantly, or 1 second, sometimes 10 seconds. GetAsync will yield the script until a respond is given.","title":"1. GetAsync"},{"location":"Luau-Learning/HttpService/#11-indicating-the-target-url","text":"GetAsync consists of 3 parameters. We will only use the first one, the url endpoint parameter. Now, we need to determine the endpoint URL. An endpoint URL is basically where the information is shown , and in this example I will use the following URL: * https://api.mcsrvstat.us/2/mc.hypixel.net","title":"1.1. Indicating the target URL"},{"location":"Luau-Learning/HttpService/#12-find-the-information","text":"When you open the URL, you will see a very long and confusing text (unless you're using Firefox, they have a very nice viewer for JSON). This is the JSON that is containing information regarding Hypixel. Now, our initial goal is to find the amount of online players . You might have a hard time finding it so I'll do the hard job for you (just this once alright). Attention This line indicates that there are, as of the time this image is taken, 40737 online players. Keep in mind that this number is NOT constant because players join and leave every moment. These kind of results are expected to change all the time.","title":"1.2. Find the information"},{"location":"Luau-Learning/HttpService/#13-coding","text":"Now we know where is the information to get, time to open Roblox Studio. HttpService requests should always be handled within a Script under ServerScriptService . Create one by right clicking the \"ServerScriptService\" -> Insert Object... -> Script . Name the script however you want! Now, take a close look at the following script. Each comment will help you understand each line of code. Code Output -- Get the HttpService through the GetService() method local HttpService = game : GetService ( \"HttpService\" ) -- Declare the target URL -- URL must be put inside quotes. If there're quotes within the URL, use \\ to escape it local URL = \"https://api.mcsrvstat.us/2/mc.hypixel.net\" -- As mentioned, GetAsync will return the information so we have to put it into a variable local info = HttpService : GetAsync ( URL ) -- Print the information into the Output window -- If you can't see the Output, go to View -> Output print ( info ) { \"ip\" : \"172.65.230.166\" , \"port\" : 25565 , \"debug\" :{ \"ping\" : true , \"query\" : false , \"srv\" : false , \"querymismatch\" : false , \"ipinsrv\" : false , \"cnameinsrv\" : false , \"animatedmotd\" : false , \"cachetime\" : 1657866731 , \"apiversion\" : 2 }, \"motd\" :{ \"raw\" :[ \" \\u00a7aHypixel Network \\u00a7c[1.8-1.19]\" , \" \\u00a76\\u00a7lSUMMER EVENT \\u00a77- \\u00a7e\\u00a7lLEVEL UP, NEW COSMETICS\" ], \"clean\" :[ \" Hypixel Network [1.8-1.19]\" , \" SUMMER EVENT - LEVEL UP, NEW COSMETICS\" ], \"html\" :[ \" <span style=\\\"color: #55FF55\\\">Hypixel Network <\\/span><span style=\\\"color: #FF5555\\\">[1.8-1.19]<\\/span>\" , \" <span style=\\\"color: #FFAA00\\\"><span style=\\\"font-weight: bold;\\\">SUMMER EVENT <\\/span><\\/span><span style=\\\"color: #AAAAAA\\\">- <\\/span><span style=\\\"color: #FFFF55\\\"><span style=\\\"font-weight: bold;\\\">LEVEL UP, NEW COSMETICS<\\/span><\\/span>\" ]}, \"players\" :{ \"online\" : 39948 , \"max\" : 200000 }, ..... Now the output will look the same as the JSON screen when we open the URL. But we haven't done yet.","title":"1.3. Coding"},{"location":"Luau-Learning/HttpService/#2-jsondecode","text":"Luau (the programming language that Roblox uses) by itself can NOT handle JSON format. The output you're looking at is a string version of the raw JSON data, and it is a nightmare to work with. Thankfully though, HttpService has another method that can help us turning a JSON mess into something we can code with, the JSONDecode method. Note JSONDecode can be used whether or not the HttpService is enabled. So far, our code look like this (without the comments): local HttpService = game : GetService ( \"HttpService\" ) local URL = \"https://api.mcsrvstat.us/2/mc.hypixel.net\" local info = HttpService : GetAsync ( URL ) -- Raw JSON print ( info ) info right now is a string version of the raw JSON information. JSONDecode will turn it into a dictionary . JSONDecode has only one parameter, the raw JSON respond returned by GetAsync . Wait, why dictionary? JSON and Luau's dictionary share the same key-value pairs behavior, so the engine can easily \"decode\" it. After decoding, we can start indexing the information like how we did normally. JSON { \"key\" : \"value\" } Luau local dict = { key = \"value\" -- or [\"key\"] = \"value\" } print ( dict . key ) --> value The method is simple: Script Output local HttpService = game : GetService ( \"HttpService\" ) local URL = \"https://api.mcsrvstat.us/2/mc.hypixel.net\" local info = HttpService : GetAsync ( URL ) -- Raw JSON local info_dict = HttpService : JSONDecode ( info ) -- Decoded JSON print ( info_dict ) -- Print the info Note: I've cut off some of the output to keep this screen short. Your output will be filled with a alot of bizzare base64 code, but the format will be the same! Within your output, click the arrow \"\u25b6\" to expand a table that looks like {...} . { [ \"debug\" ] = \u25b6 {...}, [ \"hostname\" ] = \"mc.hypixel.net\" , [ \"icon\" ] = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAA......zrDmHEPQgkAAAAASUVORK5CYII=\" , [ \"ip\" ] = \"172.65.236.36\" , [ \"motd\" ] = \u25b6 {...}, [ \"online\" ] = true , [ \"players\" ] = \u25bc { [ \"max\" ] = 200000 , [ \"online\" ] = 39694 }, [ \"port\" ] = 25565 , [ \"protocol\" ] = 47 , [ \"version\" ] = \"Requires MC 1.8 / 1.19\" } Hey look, it's the players information we're looking for! The amount of players have changed , but we have talked this through. Great, we now have a scriptable data table, all we have to do now is indexing the data . local HttpService = game : GetService ( \"HttpService\" ) local URL = \"https://api.mcsrvstat.us/2/mc.hypixel.net\" local info = HttpService : GetAsync ( URL ) local info_dict = HttpService : JSONDecode ( info ) local online_players = info_dict . players . online -- indexing the key print ( \"There are \" .. online_players .. \" players in Hypixel.\" ) Take a look at your output, you will see a line like There are 32093 players in Hypixel . Of course, this number is not constant, but if you do see one, that means the request has successfully been done and you have a basic idea of know how to use GetAsync and JSONDecode !","title":"2. JSONDecode"},{"location":"Luau-Learning/HttpService/#improvements","text":"While the URL I picked for you is relatively stable and accurate and the Hypixel server is likely never go offline, sometimes maintenance or sudden outage can occur, and either one of them will be down. This cause 2 problems to appear: * The endpoint URL is inaccessible, making the HttpService errored. * The request return an error (caused by the offline Hypixel server), making the HttpService errored. These are of course not the only problems that might appear during a request. So we will need a proper method to handle such occasions. This is where pcall() comes to handy. pcall() , or p rotected call , is used when a function might fail. pcall() return 2 values: success and a value returned by the function. We will protect our request like so: local HttpService = game : GetService ( \"HttpService\" ) local URL = \"https://api.mcsrvstat.us/2/mc.hypixel.net\" local success , info = pcall ( function () local raw_info = HttpService : GetAsync ( URL ) local info_dict = HttpService : JSONDecode ( raw_info ) return info_dict -- the \"info\" variable will be the \"info_dict\" we returned. end ) if success then -- success is a boolean value, it should be self-explanatory. local online_players = info_dict . players . online print ( \"There are \" .. online_players .. \" players in Hypixel.\" ) else warn ( 'Error occurred! ' .. info ) -- This \"info\" variable will handle our error messages. You can start your debugging process based on this. end","title":"*. Improvements"},{"location":"Luau-Learning/HttpService/#3-postasync","text":"PostAsync is a method that \"post\" data to a specified web server (this is commonly written as \"POST requests\") and handle results that returned by said server. However, PostAsync can not be replaced by GetAsync and vice versa . This is because some web servers are designated to handle GET or POST requests only. PostAsync has 5 parameters, the first 2 are mandatory : * The target url endpoint. * The data to be sent to the target. PostAsync can be used to make, for example, a feedback system in Roblox, where players send feedback to the feedback section and developers will based on that to improve the game.","title":"3. PostAsync"},{"location":"Luau-Learning/HttpService/#4-jsonencode","text":"As the name suggest, JSONEncode do the exact opposite of what JSONDecode do: convert a dictionary table to a JSON string . This raw JSON can be used as the data argument for the PostAsync method. Note JSONEncode can be used whether or not the HttpService is enabled. JSONEncode has only one parameter, a dictionary table. Here's a quick code example: Script Output local HttpService = game : GetService ( \"HttpService\" ) local info = { feedback = \"This game is epic\" , rate = 9 , player = \"shogi\" } local json = HttpService : JSONEncode ( info ) -- Raw JSON in string type print ( json ) { \"feedback\" : \"This game is epic\" , \"player\" : \"shogi\" , \"rate\" : 9 } Note If one of the value in the dictionary is nil , that key-value pair will be ignored. That means it will not be translated to JSON null value.","title":"4. JSONEncode"},{"location":"Luau-Learning/HttpService/#additional-links","text":"Official Roblox HttpService documentation More about HTTP Requests More about the JSON format","title":"Additional links"},{"location":"Luau-Learning/HttpService/#thats-about-it","text":"I hope you can use the service to improve your game experience. Good luck bai","title":"That's about it"},{"location":"Luau-Learning/If_statements/","text":"If statements What are if statements? If statements offer you a way to only run a certain piece of code if a certain condition holds true. They are a very important part of programming. You might have a door in your game that only players that are level 20 or above should be able to pass, you would use an if statement to check if the player's level is greater than or equal to 20 and only then open it. How to use if statements? Let's look at some examples. if true then print ( \"It's true!\" ) end What do you expect to happen? If you guessed that it will print \"It's true!\", you're right. If statements always check if the condition between the if and the then holds true and only then execute the code. What do you think this piece of code would do? if false then print ( \"It's true.\" ) end The correct answer is that it will not print anything. It won't execute print(\"It's true.\") because the condition doesn't hold true. We can also do the same thing with variables: local myVariable = true if myVariable then print ( \"It holds true.\" ) end will also print \"It holds true.\" while local myVariable = false if myVariable then print ( \"It holds true!\" ) end won't print anything. What if we set myVariable to nil? How does if nil then behave? You can check and you will notice that it behaves just like if false then . Exercises Create a variable that holds any number and create an if statement that checks if this variable holds true and if so, print \"Yes. Numbers are treated like true.\". The solutions are on the bottom of this tutorial. Operators There are some operators you can use in the condition to make if statements even more useful. == means equal to ~= means not equal to > means greater than < means less than >= means greater than or equal to <= means less than or equal to not means the following condition doesn't hold true if 5 == 5 then print ( \"It's true!\" ) end Will print \"It's true\" and similarly, if 5 * 6 <= 12 then print ( \"It's true\" ) end won't print anything. if true == true then print ( \"It's true\" ) end will also print \"It's true\", since the condition true == true will hold true, because true is equal to true . Common mistake A common mistake that you should avoid is using = instead of == . if true = true then end will error with the errormessage \" Expected 'then' when parsing if statement, got '=' \". The operator not not basically takes the opposite, so not false would be true and not true would be false . not nil would be true . Exercises: Using an if statement, print \"3\" if 3 to the power of 10 is greater than 5 to the power of 6. Simplify not (true == true) Simplify not not true Simplify not (not (true == false)) The solutions are on the bottom of this article. elseif and else Let's say you want to print \"Yes\" if a variable holds true and \"No\" if a variable holds false. With what we have learned previously, we could do local myVariable = true if myVariable then print ( \"Yes\" ) end if myVariable == false then print ( \"No\" ) end but there is a better way using elseif . local myVariable = true if myVariable then print ( \"Yes\" ) elseif myVariable == false then print ( \"No\" ) end Notice that we do not need an end after the first if statement here, but only at the very end. Why is this better than our first code Well that's because it's more efficient. Let's say myVariable is true, now in our first code, it will perform two checks, first it will check if it's true and print \"Yes\" and then it will check if it's false. Now in our second code, it will check if myVariable is true and print \"Yes\". There won't be any further checks, so we turned 2 checks into one check. But if myVariable was false , it would still perform two checks, first checking if it's true and then checking if it's false. We don't really need to check if it's false after we've checked if it's true, because if it's not true then it must be false. This is what else does. local myVariable = false if myVariable then print ( \"Yes\" ) else print ( \"No\" ) end will only perform one check. When we were asked why the code where we used elseif or else is better than the code where we just straight forwardly used if , we said it's more efficient. You should know that the difference in performance between the two in normal use is not noticeable though and we really just do it because of the convention and readability. Exercises Check if 7^5 is greater or equal to 5^7 , if it is, print \"Yes\", if not, print \"No\" using an if and an else statement. Check if nil is equal to false , if it is, print \"Yes\", if not, print \"No\" using an if and an elseif statement. The solutions are on the bottom of this article. Checking if an object exists If statements are also often used to check if an object exists. You can use objects in the condition and they will be treated as true . if workspace . Baseplate then print ( \"True\" ) end Would print \"True\". But if Baseplate didn't exist, this would error with the errormessage \" Attempt to index nil with Baseplate \". So how can we safely check if an object exists or not, if we just use . like in the example above, it will error if it doesn't? => We can use :FindFirstChild(). Using FindFirstChild in the condition FindFirstChild will return the object if it exists and nil if it doesn't. As we know from what we've learned previously, nil in the condition will be treated like false , so this is a safe way of checking if an object exists or not. So if we are not sure whether the baseplate exists or not, we could use if workspace : FindFirstChild ( \"Baseplate\" ) then print ( \"The baseplate exists!\" ) else print ( \"The baseplate doesn't exist!\" ) end Logical Operators Using logical operators, you can often shorten code that uses if statements by a lot. The two logical operators are or and and . How to use or condition1 or condition2 checks if either is true (or both). For example, false or true would hold true , true or true would also hold true, but false or false would hold false, since both aren't true. Both are treated as true => selects first If both of the conditions are treated as true, it will select the first, for example 1 or 2 would be 1 , right away selecting 1 after seeing that it holds true. Both are treated as false => selects last If both of the conditions are treated as false, it will select the last, for example nil or false would be false but false or nil would be nil . How to use and condition1 and condition2 checks if both condition1 and condition2 are true. For example, false and true would be false, false and false would be false but true and true would be true. Both are treated as true => selects last If both of the conditions are treated as true, it will select the last, for example 3 and 4 would be 4 . Both are treated as false => selects first If both of the conditions are treated as false, it will select the first, for example nil and false would be nil , but false and nil would be false. Using Logical Operators Let's say we have a variable and we want to check if it's 3 or 5. Here is how we would do that: local myVariable = 3 if myVariable == 3 or myVariable == 5 then print ( \"True\" ) end Common mistake A common mistake is using if myVariable == 3 or 5 here. While reading this aloud might make it sound fine, it will be the same as just if myVariable == 3 , as we've learned from \" Both are treated as true => selects first \". You need to include myVariable == for each condition to actually make it a check if it's either 3 or 5, like we did above. Exercises Simplify (true and false) or (false and true) Make a variable that holds \"Admin\". Then, check if that variable is either \"Admin\" or \"Mod\" and if so, print \"True.\" Using logical operators, make a variable hold the number 1 if Baseplate exists in workspace and 2 if not. The solutions are on the bottom of this article. Conclusion Thanks for reading. If you find any mistakes, you can report them . Solutions How to use if statements? 1. local number = 5 if number then print ( \"Yes. Numbers are treated like true.\" ) end Operators 2. if 3 ^ 10 > 5 ^ 6 then print ( \"3\" ) end not (true == true) ==> not true ==> false not not true ==> not false ==> true not (not (true == false)) = not (not (false)) = not (true) = false elseif and else 1. if 7 ^ 5 >= 5 ^ 7 then print ( \"Yes\" ) else print ( \"No\" ) end 2. if nil == false then print ( \"Yes\" ) elseif nil ~= false then print ( \"No\" ) end Logical Operators (true and false) or (false and true) ==> false or false ==> false local myVariable = \"Admin\" if myVariable == \"Admin\" or myVariable == \"Mod\" then print ( \"True.\" ) end local myVariable = workspace : FindFirstChild ( \"Baseplate\" ) and 1 or 2","title":"If statements"},{"location":"Luau-Learning/If_statements/#if-statements","text":"","title":"If statements"},{"location":"Luau-Learning/If_statements/#what-are-if-statements","text":"If statements offer you a way to only run a certain piece of code if a certain condition holds true. They are a very important part of programming. You might have a door in your game that only players that are level 20 or above should be able to pass, you would use an if statement to check if the player's level is greater than or equal to 20 and only then open it.","title":"What are if statements?"},{"location":"Luau-Learning/If_statements/#how-to-use-if-statements","text":"Let's look at some examples. if true then print ( \"It's true!\" ) end What do you expect to happen? If you guessed that it will print \"It's true!\", you're right. If statements always check if the condition between the if and the then holds true and only then execute the code. What do you think this piece of code would do? if false then print ( \"It's true.\" ) end The correct answer is that it will not print anything. It won't execute print(\"It's true.\") because the condition doesn't hold true. We can also do the same thing with variables: local myVariable = true if myVariable then print ( \"It holds true.\" ) end will also print \"It holds true.\" while local myVariable = false if myVariable then print ( \"It holds true!\" ) end won't print anything. What if we set myVariable to nil? How does if nil then behave? You can check and you will notice that it behaves just like if false then .","title":"How to use if statements?"},{"location":"Luau-Learning/If_statements/#exercises","text":"Create a variable that holds any number and create an if statement that checks if this variable holds true and if so, print \"Yes. Numbers are treated like true.\". The solutions are on the bottom of this tutorial.","title":"Exercises"},{"location":"Luau-Learning/If_statements/#operators","text":"There are some operators you can use in the condition to make if statements even more useful. == means equal to ~= means not equal to > means greater than < means less than >= means greater than or equal to <= means less than or equal to not means the following condition doesn't hold true if 5 == 5 then print ( \"It's true!\" ) end Will print \"It's true\" and similarly, if 5 * 6 <= 12 then print ( \"It's true\" ) end won't print anything. if true == true then print ( \"It's true\" ) end will also print \"It's true\", since the condition true == true will hold true, because true is equal to true .","title":"Operators"},{"location":"Luau-Learning/If_statements/#common-mistake","text":"A common mistake that you should avoid is using = instead of == . if true = true then end will error with the errormessage \" Expected 'then' when parsing if statement, got '=' \".","title":"Common mistake"},{"location":"Luau-Learning/If_statements/#the-operator-not","text":"not basically takes the opposite, so not false would be true and not true would be false . not nil would be true .","title":"The operator not"},{"location":"Luau-Learning/If_statements/#exercises_1","text":"Using an if statement, print \"3\" if 3 to the power of 10 is greater than 5 to the power of 6. Simplify not (true == true) Simplify not not true Simplify not (not (true == false)) The solutions are on the bottom of this article.","title":"Exercises:"},{"location":"Luau-Learning/If_statements/#elseif-and-else","text":"Let's say you want to print \"Yes\" if a variable holds true and \"No\" if a variable holds false. With what we have learned previously, we could do local myVariable = true if myVariable then print ( \"Yes\" ) end if myVariable == false then print ( \"No\" ) end but there is a better way using elseif . local myVariable = true if myVariable then print ( \"Yes\" ) elseif myVariable == false then print ( \"No\" ) end Notice that we do not need an end after the first if statement here, but only at the very end.","title":"elseif and else"},{"location":"Luau-Learning/If_statements/#why-is-this-better-than-our-first-code","text":"Well that's because it's more efficient. Let's say myVariable is true, now in our first code, it will perform two checks, first it will check if it's true and print \"Yes\" and then it will check if it's false. Now in our second code, it will check if myVariable is true and print \"Yes\". There won't be any further checks, so we turned 2 checks into one check. But if myVariable was false , it would still perform two checks, first checking if it's true and then checking if it's false. We don't really need to check if it's false after we've checked if it's true, because if it's not true then it must be false. This is what else does. local myVariable = false if myVariable then print ( \"Yes\" ) else print ( \"No\" ) end will only perform one check. When we were asked why the code where we used elseif or else is better than the code where we just straight forwardly used if , we said it's more efficient. You should know that the difference in performance between the two in normal use is not noticeable though and we really just do it because of the convention and readability.","title":"Why is this better than our first code"},{"location":"Luau-Learning/If_statements/#exercises_2","text":"Check if 7^5 is greater or equal to 5^7 , if it is, print \"Yes\", if not, print \"No\" using an if and an else statement. Check if nil is equal to false , if it is, print \"Yes\", if not, print \"No\" using an if and an elseif statement. The solutions are on the bottom of this article.","title":"Exercises"},{"location":"Luau-Learning/If_statements/#checking-if-an-object-exists","text":"If statements are also often used to check if an object exists. You can use objects in the condition and they will be treated as true . if workspace . Baseplate then print ( \"True\" ) end Would print \"True\". But if Baseplate didn't exist, this would error with the errormessage \" Attempt to index nil with Baseplate \". So how can we safely check if an object exists or not, if we just use . like in the example above, it will error if it doesn't? => We can use :FindFirstChild().","title":"Checking if an object exists"},{"location":"Luau-Learning/If_statements/#using-findfirstchild-in-the-condition","text":"FindFirstChild will return the object if it exists and nil if it doesn't. As we know from what we've learned previously, nil in the condition will be treated like false , so this is a safe way of checking if an object exists or not. So if we are not sure whether the baseplate exists or not, we could use if workspace : FindFirstChild ( \"Baseplate\" ) then print ( \"The baseplate exists!\" ) else print ( \"The baseplate doesn't exist!\" ) end","title":"Using FindFirstChild in the condition"},{"location":"Luau-Learning/If_statements/#logical-operators","text":"Using logical operators, you can often shorten code that uses if statements by a lot. The two logical operators are or and and .","title":"Logical Operators"},{"location":"Luau-Learning/If_statements/#how-to-use-or","text":"condition1 or condition2 checks if either is true (or both). For example, false or true would hold true , true or true would also hold true, but false or false would hold false, since both aren't true.","title":"How to use or"},{"location":"Luau-Learning/If_statements/#both-are-treated-as-true-selects-first","text":"If both of the conditions are treated as true, it will select the first, for example 1 or 2 would be 1 , right away selecting 1 after seeing that it holds true.","title":"Both are treated as true =&gt; selects first"},{"location":"Luau-Learning/If_statements/#both-are-treated-as-false-selects-last","text":"If both of the conditions are treated as false, it will select the last, for example nil or false would be false but false or nil would be nil .","title":"Both are treated as false =&gt; selects last"},{"location":"Luau-Learning/If_statements/#how-to-use-and","text":"condition1 and condition2 checks if both condition1 and condition2 are true. For example, false and true would be false, false and false would be false but true and true would be true.","title":"How to use and"},{"location":"Luau-Learning/If_statements/#both-are-treated-as-true-selects-last","text":"If both of the conditions are treated as true, it will select the last, for example 3 and 4 would be 4 .","title":"Both are treated as true =&gt; selects last"},{"location":"Luau-Learning/If_statements/#both-are-treated-as-false-selects-first","text":"If both of the conditions are treated as false, it will select the first, for example nil and false would be nil , but false and nil would be false.","title":"Both are treated as false =&gt; selects first"},{"location":"Luau-Learning/If_statements/#using-logical-operators","text":"Let's say we have a variable and we want to check if it's 3 or 5. Here is how we would do that: local myVariable = 3 if myVariable == 3 or myVariable == 5 then print ( \"True\" ) end","title":"Using Logical Operators"},{"location":"Luau-Learning/If_statements/#common-mistake_1","text":"A common mistake is using if myVariable == 3 or 5 here. While reading this aloud might make it sound fine, it will be the same as just if myVariable == 3 , as we've learned from \" Both are treated as true => selects first \". You need to include myVariable == for each condition to actually make it a check if it's either 3 or 5, like we did above.","title":"Common mistake"},{"location":"Luau-Learning/If_statements/#exercises_3","text":"Simplify (true and false) or (false and true) Make a variable that holds \"Admin\". Then, check if that variable is either \"Admin\" or \"Mod\" and if so, print \"True.\" Using logical operators, make a variable hold the number 1 if Baseplate exists in workspace and 2 if not. The solutions are on the bottom of this article.","title":"Exercises"},{"location":"Luau-Learning/If_statements/#conclusion","text":"Thanks for reading. If you find any mistakes, you can report them .","title":"Conclusion"},{"location":"Luau-Learning/If_statements/#solutions","text":"","title":"Solutions"},{"location":"Luau-Learning/If_statements/#how-to-use-if-statements_1","text":"1. local number = 5 if number then print ( \"Yes. Numbers are treated like true.\" ) end","title":"How to use if statements?"},{"location":"Luau-Learning/If_statements/#operators_1","text":"2. if 3 ^ 10 > 5 ^ 6 then print ( \"3\" ) end not (true == true) ==> not true ==> false not not true ==> not false ==> true not (not (true == false)) = not (not (false)) = not (true) = false","title":"Operators"},{"location":"Luau-Learning/If_statements/#elseif-and-else_1","text":"1. if 7 ^ 5 >= 5 ^ 7 then print ( \"Yes\" ) else print ( \"No\" ) end 2. if nil == false then print ( \"Yes\" ) elseif nil ~= false then print ( \"No\" ) end","title":"elseif and else"},{"location":"Luau-Learning/If_statements/#logical-operators_1","text":"(true and false) or (false and true) ==> false or false ==> false local myVariable = \"Admin\" if myVariable == \"Admin\" or myVariable == \"Mod\" then print ( \"True.\" ) end local myVariable = workspace : FindFirstChild ( \"Baseplate\" ) and 1 or 2","title":"Logical Operators"},{"location":"Luau-Learning/Introduction_To_Studio/","text":"Introduction To Studio Roblox studio is used for developing games in Roblox. It has lots of cool features and stuff and is one of the best game engines. Downloading Studio Setting up studio First of all, you need to set up your studio. Explorer Explorer window displays every object inside the data model in a tree structure. Here is how it looks like It is enabled by default but if you ever need to disable/enable it, you can from the view tab on the top bar. Properties The properties window displays all the visible properties of the selected object. It can be enabled from the view tab on the top bar. In the above picture, it is displaying properties of a part named Baseplate . It is an important part of the studio and you will always need it whenever you have to change the property of an object manually. Output Window The output window is basically a window that displays, anything you print, warnings, errors, and other messages of such sorts. You can enable it from the top bar. Click the view tab and select output . Introduction To Scripting. Scripting is an essential part of Roblox development. To get optimum benefit of Roblox's services, instances, etc you would require scripting. In fact, you can not make a game in Roblox without scripting it. Roblox engine uses Luau for scripting, a modified version of Lua. Like almost all high-level languages, the fundamentals of Lua are pretty easy to learn. Now, let's go through some elemental stuff regarding Roblox scripting. Adding Scripts To add a script inside of any of the objects, click the icon, next to that object in the explorer window. As an example, we have added a script in \"ServerScriptService\". This is how we can add a script. Printing. print() is a Lua global, mainly used for debugging. In the studio, when you print something it is displayed on the output window. As an example use, we will print the sum of two numbers. print ( 17 + 19 ) You can see the output on the output window. Closing! That's pretty much of it. Hope you enjoyed reading it. In case of any mistake, typos, etc. Please report the article. You can also give us reviews here","title":"Introduction To Studio"},{"location":"Luau-Learning/Introduction_To_Studio/#introduction-to-studio","text":"Roblox studio is used for developing games in Roblox. It has lots of cool features and stuff and is one of the best game engines. Downloading Studio","title":"Introduction To Studio"},{"location":"Luau-Learning/Introduction_To_Studio/#setting-up-studio","text":"First of all, you need to set up your studio.","title":"Setting up studio"},{"location":"Luau-Learning/Introduction_To_Studio/#explorer","text":"Explorer window displays every object inside the data model in a tree structure. Here is how it looks like It is enabled by default but if you ever need to disable/enable it, you can from the view tab on the top bar.","title":"Explorer"},{"location":"Luau-Learning/Introduction_To_Studio/#properties","text":"The properties window displays all the visible properties of the selected object. It can be enabled from the view tab on the top bar. In the above picture, it is displaying properties of a part named Baseplate . It is an important part of the studio and you will always need it whenever you have to change the property of an object manually.","title":"Properties"},{"location":"Luau-Learning/Introduction_To_Studio/#output-window","text":"The output window is basically a window that displays, anything you print, warnings, errors, and other messages of such sorts. You can enable it from the top bar. Click the view tab and select output .","title":"Output Window"},{"location":"Luau-Learning/Introduction_To_Studio/#introduction-to-scripting","text":"Scripting is an essential part of Roblox development. To get optimum benefit of Roblox's services, instances, etc you would require scripting. In fact, you can not make a game in Roblox without scripting it. Roblox engine uses Luau for scripting, a modified version of Lua. Like almost all high-level languages, the fundamentals of Lua are pretty easy to learn. Now, let's go through some elemental stuff regarding Roblox scripting.","title":"Introduction To Scripting."},{"location":"Luau-Learning/Introduction_To_Studio/#adding-scripts","text":"To add a script inside of any of the objects, click the icon, next to that object in the explorer window. As an example, we have added a script in \"ServerScriptService\". This is how we can add a script.","title":"Adding Scripts"},{"location":"Luau-Learning/Introduction_To_Studio/#printing","text":"print() is a Lua global, mainly used for debugging. In the studio, when you print something it is displayed on the output window. As an example use, we will print the sum of two numbers. print ( 17 + 19 ) You can see the output on the output window.","title":"Printing."},{"location":"Luau-Learning/Introduction_To_Studio/#closing","text":"That's pretty much of it. Hope you enjoyed reading it. In case of any mistake, typos, etc. Please report the article. You can also give us reviews here","title":"Closing!"},{"location":"Luau-Learning/More_on_Dictionaries/","text":"For real? There's more? ...Yes. The ROBLOX API actually uses dictionaries far more often than you'd imagine. This is what I will be going through in this article. To progress on however, you are expected to have a basic understanding of tables and sufficient experience with at least for loops. You can read them up with the tables guide in the Lua Learning section! The Beginning Recall how to get a value from a dictionary: local dictionary = { [ \"One\" ] = 1 , [ \"Two\" ] = 2 , [ \"Three\" ] = 3 , [ \"Four\" ] = 4 , [ \"Five\" ] = 5 } print ( dictionary [ \"One\" ]) -- Output: -- 1 This should look very familiar to you if you've used dictionaries for even a short length of time. However, what if I told you there's another way to access a value in a dictionary? Watch this demonstration. local dictionary = { [ \"One\" ] = 1 , [ \"Two\" ] = 2 , [ \"Three\" ] = 3 , [ \"Four\" ] = 4 , [ \"Five\" ] = 5 } print ( dictionary . One ) -- Output: -- 1 That's right! You can actually access a dictionary's value just by using . followed by the key name. Hold onto this - while this alone may seem like an unnecessary feature, this article will build on top of this concept. I will cover exactly why this can be useful. Explorer as a Dictionary If you're new to this concept, you might want to hold onto your chair tight and hope you don't get blown back far into your seat: The game world is really just a massive dictionary. That's right, it actually is! Remember the demonstration we just did? Now compare it to this: -- print(dictionary.One) print ( workspace . Baseplate . Name ) -- workspace is a global namespace for the Workspace object. -- Output: -- Baseplate Do you see the similarity? Let's apply what we learnt earlier on and see if it works: -- print(dictionary[\"One\"]) print ( workspace [ \"Baseplate\" ]. Name ) -- Output: -- Baseplate This is what I meant! The game is really just a massive dictionary where the objects are the keys, and the instances are the values. In summary, you can get an object with either of these two ways in consideration that the game is a dictionary: print ( workspace . Baseplate . Name ) print ( workspace [ \"Baseplate\" ]. Name ) -- Both will return \"Baseplate\". This is cool, isn't it? But hold on, there's more. Properties as a Dictionary Let's use the example from before: print ( workspace . Baseplate . Name ) print ( workspace [ \"Baseplate\" ]. Name ) Now here's another shocker: An instance is also another dictionary. Yes! Using the same few demonstrations above, we can access the property of an instance like as if it was part of a dictionary: print ( workspace . Baseplate . Name ) print ( workspace . Baseplate [ \"Name\" ]) -- Both will return \"Baseplate\". The next section will detail how you can apply what you have just discovered into one of the most common constructs/instructions in scripting - setting properties of an instance. Setting properties with loops One of the biggest uses of such a feature is that you can set the properties of an object by using a loop. Let's take a look at the typical approach that you might instinctively use: local name = \"PartName\" local material = Enum . Material . SmoothPlastic local position = Vector3 . new ( 0 , 0 , 0 ) local size = Vector3 . new ( 1 , 1 , 1 ) workspace . Baseplate . Name = name workspace . Baseplate . Material = material workspace . Baseplate . Position = position workspace . Baseplate . Size = size While this could work, it is not very scalable - not only do you have to store lots of variables, code like this can get very difficult to edit especially when you have lots of properties to change. It also becomes very repetitive when you have many properties to set for an instance. Fret not, we can change all that using dictionaries and a generic for loop. local propertyDictionary = { -- [\"Property Name\"] = \"Value\" [ \"Name\" ] = \"PartName\" , [ \"Material\" ] = Enum . Material . SmoothPlastic , [ \"Position\" ] = Vector3 . new ( 0 , 0 , 0 ), [ \"Size\" ] = Vector3 . new ( 1 , 1 , 1 ), } for property , value in pairs ( propertyDictionary ) do workspace . Baseplate [ property ] = value end Undoubtedly, this looks way cleaner than our initial approach. Not only that, because we stored our property values in an easy-to-access table, we know exactly where to look when we need to edit a property for our parts in the future. This saves on development time, and is less taxing to maintain. Things like this really add up when you have multiple parts to change the properties of: local parts = { workspace . Part1 , workspace . Part2 , workspace . Part3 } local propertyDictionary = { -- [\"Property Name\"] = \"Value\" [ \"Name\" ] = \"PartName\" , [ \"Material\" ] = Enum . Material . SmoothPlastic , [ \"Position\" ] = Vector3 . new ( 0 , 0 , 0 ), [ \"Size\" ] = Vector3 . new ( 1 , 1 , 1 ), } for index , part in ipairs ( parts ) do for property , value in pairs ( propertyDictionary ) do part [ property ] = value end end Do make sure to provide the correct property name for your keys however. Otherwise, your script may throw a nil error! Closing The article is an extension to dictionaries. We hope it helped you in improving your concepts. Thanks for reading!","title":"More on Dictionaries"},{"location":"Luau-Learning/More_on_Dictionaries/#for-real-theres-more","text":"...Yes. The ROBLOX API actually uses dictionaries far more often than you'd imagine. This is what I will be going through in this article. To progress on however, you are expected to have a basic understanding of tables and sufficient experience with at least for loops. You can read them up with the tables guide in the Lua Learning section!","title":"For real? There's more?"},{"location":"Luau-Learning/More_on_Dictionaries/#the-beginning","text":"Recall how to get a value from a dictionary: local dictionary = { [ \"One\" ] = 1 , [ \"Two\" ] = 2 , [ \"Three\" ] = 3 , [ \"Four\" ] = 4 , [ \"Five\" ] = 5 } print ( dictionary [ \"One\" ]) -- Output: -- 1 This should look very familiar to you if you've used dictionaries for even a short length of time. However, what if I told you there's another way to access a value in a dictionary? Watch this demonstration. local dictionary = { [ \"One\" ] = 1 , [ \"Two\" ] = 2 , [ \"Three\" ] = 3 , [ \"Four\" ] = 4 , [ \"Five\" ] = 5 } print ( dictionary . One ) -- Output: -- 1 That's right! You can actually access a dictionary's value just by using . followed by the key name. Hold onto this - while this alone may seem like an unnecessary feature, this article will build on top of this concept. I will cover exactly why this can be useful.","title":"The Beginning"},{"location":"Luau-Learning/More_on_Dictionaries/#explorer-as-a-dictionary","text":"If you're new to this concept, you might want to hold onto your chair tight and hope you don't get blown back far into your seat: The game world is really just a massive dictionary. That's right, it actually is! Remember the demonstration we just did? Now compare it to this: -- print(dictionary.One) print ( workspace . Baseplate . Name ) -- workspace is a global namespace for the Workspace object. -- Output: -- Baseplate Do you see the similarity? Let's apply what we learnt earlier on and see if it works: -- print(dictionary[\"One\"]) print ( workspace [ \"Baseplate\" ]. Name ) -- Output: -- Baseplate This is what I meant! The game is really just a massive dictionary where the objects are the keys, and the instances are the values. In summary, you can get an object with either of these two ways in consideration that the game is a dictionary: print ( workspace . Baseplate . Name ) print ( workspace [ \"Baseplate\" ]. Name ) -- Both will return \"Baseplate\". This is cool, isn't it? But hold on, there's more.","title":"Explorer as a Dictionary"},{"location":"Luau-Learning/More_on_Dictionaries/#properties-as-a-dictionary","text":"Let's use the example from before: print ( workspace . Baseplate . Name ) print ( workspace [ \"Baseplate\" ]. Name ) Now here's another shocker: An instance is also another dictionary. Yes! Using the same few demonstrations above, we can access the property of an instance like as if it was part of a dictionary: print ( workspace . Baseplate . Name ) print ( workspace . Baseplate [ \"Name\" ]) -- Both will return \"Baseplate\". The next section will detail how you can apply what you have just discovered into one of the most common constructs/instructions in scripting - setting properties of an instance.","title":"Properties as a Dictionary"},{"location":"Luau-Learning/More_on_Dictionaries/#setting-properties-with-loops","text":"One of the biggest uses of such a feature is that you can set the properties of an object by using a loop. Let's take a look at the typical approach that you might instinctively use: local name = \"PartName\" local material = Enum . Material . SmoothPlastic local position = Vector3 . new ( 0 , 0 , 0 ) local size = Vector3 . new ( 1 , 1 , 1 ) workspace . Baseplate . Name = name workspace . Baseplate . Material = material workspace . Baseplate . Position = position workspace . Baseplate . Size = size While this could work, it is not very scalable - not only do you have to store lots of variables, code like this can get very difficult to edit especially when you have lots of properties to change. It also becomes very repetitive when you have many properties to set for an instance. Fret not, we can change all that using dictionaries and a generic for loop. local propertyDictionary = { -- [\"Property Name\"] = \"Value\" [ \"Name\" ] = \"PartName\" , [ \"Material\" ] = Enum . Material . SmoothPlastic , [ \"Position\" ] = Vector3 . new ( 0 , 0 , 0 ), [ \"Size\" ] = Vector3 . new ( 1 , 1 , 1 ), } for property , value in pairs ( propertyDictionary ) do workspace . Baseplate [ property ] = value end Undoubtedly, this looks way cleaner than our initial approach. Not only that, because we stored our property values in an easy-to-access table, we know exactly where to look when we need to edit a property for our parts in the future. This saves on development time, and is less taxing to maintain. Things like this really add up when you have multiple parts to change the properties of: local parts = { workspace . Part1 , workspace . Part2 , workspace . Part3 } local propertyDictionary = { -- [\"Property Name\"] = \"Value\" [ \"Name\" ] = \"PartName\" , [ \"Material\" ] = Enum . Material . SmoothPlastic , [ \"Position\" ] = Vector3 . new ( 0 , 0 , 0 ), [ \"Size\" ] = Vector3 . new ( 1 , 1 , 1 ), } for index , part in ipairs ( parts ) do for property , value in pairs ( propertyDictionary ) do part [ property ] = value end end Do make sure to provide the correct property name for your keys however. Otherwise, your script may throw a nil error!","title":"Setting properties with loops"},{"location":"Luau-Learning/More_on_Dictionaries/#closing","text":"The article is an extension to dictionaries. We hope it helped you in improving your concepts. Thanks for reading!","title":"Closing"},{"location":"Luau-Learning/Players_Service/","text":"Players Service Simplified Hey! In this article, you'll learn how to use the Players Service . Before we begin, make sure you understand the basics of Roblox Scripting. You could start here . This tutorial may not cover all of the Players service, but only the most frequently used parts! What is the Players Service? The Players service is a service that contains all the players who are presently connecting their clients to a Roblox game server. You can access things such as a player's friends, avatar, username, etc. Basic Events PlayerAdded This event fires when a player enters the game. Basic Usage local Players = game : GetService ( \"Players\" ) Players . PlayerAdded : Connect ( function ( player ) print ( player . Name .. \" has joined the game!\" ) end ) In the first line, we assign the Players service to a variable Players . In the third line we use the PlayerAdded event, which gets us the player that is joining when the event was fired. And then, we print out the player's name! PlayerAdded sometimes doesn't properly function in solo mode i.e in Roblox Studio. PlayerRemoving This event is very similar to PlayerAdded, except it fires when a player leaves the game. Basic Usage local Players = game : GetService ( \"Players\" ) Players . PlayerRemoving : Connect ( function ( player ) print ( player . Name .. \"has left the game!\" ) end ) Basic Methods GetPlayers This method returns an array of player(s) that are currently in the server at the time of calling this method. Basic Usage Players = game : GetService ( \"Players\" ) for i , player in ipairs ( Players : GetPlayers ()) do print ( player . Name ) end The following code will print all of the players' names that are currently on the server at the time. GetPlayerFromCharacter This method returns the player associated with the given character, or nil if one cannot be found. Basic Usage local Players = game : GetService ( \"Players\" ) local character = workspace . Player --the character of a player. Change the \"Player\" to your username. local player = Players : GetPlayerFromCharacter ( character ) GetPlayerByUserId This method returns the player who has the given UserId in the server. Basic Usage local Players = game : GetService ( \"Players\" ) local player = Players : GetPlayerByUserId ( 123 ) This will return the player with the given UserId if they are on the server, or else it will return nil.","title":"Players Service Simplified"},{"location":"Luau-Learning/Players_Service/#players-service-simplified","text":"Hey! In this article, you'll learn how to use the Players Service . Before we begin, make sure you understand the basics of Roblox Scripting. You could start here . This tutorial may not cover all of the Players service, but only the most frequently used parts!","title":"Players Service Simplified"},{"location":"Luau-Learning/Players_Service/#what-is-the-players-service","text":"The Players service is a service that contains all the players who are presently connecting their clients to a Roblox game server. You can access things such as a player's friends, avatar, username, etc.","title":"What is the Players Service?"},{"location":"Luau-Learning/Players_Service/#basic-events","text":"","title":"Basic Events"},{"location":"Luau-Learning/Players_Service/#playeradded","text":"This event fires when a player enters the game.","title":"PlayerAdded"},{"location":"Luau-Learning/Players_Service/#basic-usage","text":"local Players = game : GetService ( \"Players\" ) Players . PlayerAdded : Connect ( function ( player ) print ( player . Name .. \" has joined the game!\" ) end ) In the first line, we assign the Players service to a variable Players . In the third line we use the PlayerAdded event, which gets us the player that is joining when the event was fired. And then, we print out the player's name! PlayerAdded sometimes doesn't properly function in solo mode i.e in Roblox Studio.","title":"Basic Usage"},{"location":"Luau-Learning/Players_Service/#playerremoving","text":"This event is very similar to PlayerAdded, except it fires when a player leaves the game.","title":"PlayerRemoving"},{"location":"Luau-Learning/Players_Service/#basic-usage_1","text":"local Players = game : GetService ( \"Players\" ) Players . PlayerRemoving : Connect ( function ( player ) print ( player . Name .. \"has left the game!\" ) end )","title":"Basic Usage"},{"location":"Luau-Learning/Players_Service/#basic-methods","text":"","title":"Basic Methods"},{"location":"Luau-Learning/Players_Service/#getplayers","text":"This method returns an array of player(s) that are currently in the server at the time of calling this method.","title":"GetPlayers"},{"location":"Luau-Learning/Players_Service/#basic-usage_2","text":"Players = game : GetService ( \"Players\" ) for i , player in ipairs ( Players : GetPlayers ()) do print ( player . Name ) end The following code will print all of the players' names that are currently on the server at the time.","title":"Basic Usage"},{"location":"Luau-Learning/Players_Service/#getplayerfromcharacter","text":"This method returns the player associated with the given character, or nil if one cannot be found.","title":"GetPlayerFromCharacter"},{"location":"Luau-Learning/Players_Service/#basic-usage_3","text":"local Players = game : GetService ( \"Players\" ) local character = workspace . Player --the character of a player. Change the \"Player\" to your username. local player = Players : GetPlayerFromCharacter ( character )","title":"Basic Usage"},{"location":"Luau-Learning/Players_Service/#getplayerbyuserid","text":"This method returns the player who has the given UserId in the server.","title":"GetPlayerByUserId"},{"location":"Luau-Learning/Players_Service/#basic-usage_4","text":"local Players = game : GetService ( \"Players\" ) local player = Players : GetPlayerByUserId ( 123 ) This will return the player with the given UserId if they are on the server, or else it will return nil.","title":"Basic Usage"},{"location":"Luau-Learning/Position_and_Size/","text":"Changing Size and Position Previously we explained vectors, their types, addition, and product of vectors. Now we will move further and talk about its usage in changing positions and sizes. Once you have cleared your mind regarding vectors, you are surely able to understand their usage in Roblox. Changing Size When you are changing the size of a base part, the origin of the vector is at the centre of the base part. We have a part in the workspace of size (6,6,6). The blue point in the middle of the part represents the pivot point however it is in the centre, we will use this point as the origin. Now it's time to change the size of this part. We will increase its size on the y-axis by 8 studs. (As whole, it will be 14 studs on the y-axis) workspace . Part . Size = Vector3 . new ( 6 , 14 , 6 ) You can see, that our part is much bigger now. If you look carefully, you will notice the size is increased on both sides of y-axis (positive y-axis and negative y-axis). In Roblox engine, if you increase the size of a part by using a script, the engine tends to keep it in the same position. When changing size on the positive y-axis, the position of the part would have changed as the center of the part will be moved above. Because we increased the size by 8 studs, it will increase 4 studs on the positive y-axis and 4 studs on the negative y-axis. Similarly, size can be increased on other axes. Changing Positions While changing the position of a base part. The origin of a vector is the center of the world. We have a part in the center of the world which means, its position is (0,0,0) . We will change its position to (8,6,8) . We will use a vector having magnitude of 8 studs on the x-axis, 6 studs on the y-axis, and 8 studs on the z-axis. This can be done by workspace . Part . Position = Vector3 . new ( 8 , 6 , 8 ) Here we go It is indeed very easy if your concepts of vectors are clear. You might have a question, about why I explained vectors in that much detail when it was just this and that. At the basic level, you would not need to compute vectors that much but I assure you that you will need them if you want to do stuff like projectile motion, linear velocities, etc. Let's get back to our topic. Moving a part relative to its position Previously we were changing position from the center of the world. Now if you want to move a part 4 studs above which is initially placed at (8,6,8) from origin. We will simply add a vector (0,4,0) in the position vector of the part. This will be done through additon of vectors . --Getting initial position (8,6,8) local initial_position = workspace . Part . Position --adding vectors local new_position = initial_position + Vector3 . new ( 0 , 4 , 0 ) workspace . Part . Position = new_position Congrats! we succeeded in moving it 4 studs above (positive y-axis). Similarly, you can move it on the x and z axes. --Geeting initial position (8,6,8) local initial_position = workspace . Part . Position --adding vectors local new_position = initial_position + Vector3 . new ( 9 , 4 , 3 ) workspace . Part . Position = new_position Closing! That's pretty much of it. Hope you enjoyed reading it. In case of any mistake, typos, etc. Please report the article. You can also give us reviews here","title":"Changing Size and Position"},{"location":"Luau-Learning/Position_and_Size/#changing-size-and-position","text":"Previously we explained vectors, their types, addition, and product of vectors. Now we will move further and talk about its usage in changing positions and sizes. Once you have cleared your mind regarding vectors, you are surely able to understand their usage in Roblox.","title":"Changing Size and Position"},{"location":"Luau-Learning/Position_and_Size/#changing-size","text":"When you are changing the size of a base part, the origin of the vector is at the centre of the base part. We have a part in the workspace of size (6,6,6). The blue point in the middle of the part represents the pivot point however it is in the centre, we will use this point as the origin. Now it's time to change the size of this part. We will increase its size on the y-axis by 8 studs. (As whole, it will be 14 studs on the y-axis) workspace . Part . Size = Vector3 . new ( 6 , 14 , 6 ) You can see, that our part is much bigger now. If you look carefully, you will notice the size is increased on both sides of y-axis (positive y-axis and negative y-axis). In Roblox engine, if you increase the size of a part by using a script, the engine tends to keep it in the same position. When changing size on the positive y-axis, the position of the part would have changed as the center of the part will be moved above. Because we increased the size by 8 studs, it will increase 4 studs on the positive y-axis and 4 studs on the negative y-axis. Similarly, size can be increased on other axes.","title":"Changing Size"},{"location":"Luau-Learning/Position_and_Size/#changing-positions","text":"While changing the position of a base part. The origin of a vector is the center of the world. We have a part in the center of the world which means, its position is (0,0,0) . We will change its position to (8,6,8) . We will use a vector having magnitude of 8 studs on the x-axis, 6 studs on the y-axis, and 8 studs on the z-axis. This can be done by workspace . Part . Position = Vector3 . new ( 8 , 6 , 8 ) Here we go It is indeed very easy if your concepts of vectors are clear. You might have a question, about why I explained vectors in that much detail when it was just this and that. At the basic level, you would not need to compute vectors that much but I assure you that you will need them if you want to do stuff like projectile motion, linear velocities, etc. Let's get back to our topic.","title":"Changing Positions"},{"location":"Luau-Learning/Position_and_Size/#moving-a-part-relative-to-its-position","text":"Previously we were changing position from the center of the world. Now if you want to move a part 4 studs above which is initially placed at (8,6,8) from origin. We will simply add a vector (0,4,0) in the position vector of the part. This will be done through additon of vectors . --Getting initial position (8,6,8) local initial_position = workspace . Part . Position --adding vectors local new_position = initial_position + Vector3 . new ( 0 , 4 , 0 ) workspace . Part . Position = new_position Congrats! we succeeded in moving it 4 studs above (positive y-axis). Similarly, you can move it on the x and z axes. --Geeting initial position (8,6,8) local initial_position = workspace . Part . Position --adding vectors local new_position = initial_position + Vector3 . new ( 9 , 4 , 3 ) workspace . Part . Position = new_position","title":"Moving a part relative to its position"},{"location":"Luau-Learning/Position_and_Size/#closing","text":"That's pretty much of it. Hope you enjoyed reading it. In case of any mistake, typos, etc. Please report the article. You can also give us reviews here","title":"Closing!"},{"location":"Luau-Learning/RayCasting/","text":"Raycasting Roblox engine allows its users to cast an invisible ray from a Vector3 position towards a specified direction. Unlike normal rays, Roblox enables you to set the length of ray according to your needs. Using raycast, you can detect if the ray hits a Basepart or Terrain . Casting A Ray For casting a ray we use the method :Raycast() of worldroot ( workspace ). Raycast() takes three arguments and returns RaycastResult Origin type: Vector3 Direction type: Vector3 RaycastParams type: RaycastParams local Raycast_result = workspace : Raycast ( origin , direction , raycastparams ) Origin Origin of a ray is basically a Vector3 position of the world, from where the ray will start. We will take two parts . A red part and a green part and cast ray between them. local origin = RedPart . Position We have selected position of red part as origin for the ray. Direction Direction is the Vector3 with a defined magnitude. Direction of a ray from a known destination (GreenPart.Position) can be easily caluclated by using following formula Destination - Origin = Direction If you are familiar with vectors then we are basically getting a Vector3 between the two positions. Once we have calculated the directional vector, we will adjust the length of it. For doing so we will get the unit vector of directional vector and multiply it with the number of studs (the length of ray in studs). local direction = ( GreenPart . Position - RedPart . Position ). Unit * 100 In above example, the magnitude of ray is set to 100 studs. RaycastParams RaycastParams carries the parameters of Raycast() . It's property, FilterDescendantsInstances stores a table. It can be either a Blacklist or Whitelist depending on FilterType . Note Enum.RaycastFilterType.Whitelist Every BasePart other than those given in filter list and their descendants will be ignored. Enum.RaycastFilterType.Blacklist Every BasePart other than those given in filter list and their descendants will be considered. local RaycastParams = RaycastParams . new () RaycastParams . FilterDescendantsInstances = { RedPart } raycastParams . FilterType = Enum . RaycastFilterType . Blacklist In these params we have blacklisted the red part in order to prevent ray from being incident on the walls of red part. Our overall code will be: local origin = RedPart . Position local direction = ( GreenPart . Position - RedPart . Position ). Unit * 100 local RaycastParams = RaycastParams . new () RaycastParams . FilterDescendantsInstances = { RedPart } raycastParams . FilterType = Enum . RaycastFilterType . Blacklist local Raycast_result = workspace : Raycast ( origin , direction , raycastparams ) RaycastResult If the ray hits a basepart, it will return RaycastResult . It's properties carries result of raycast RaycastResult.Instance | The BasePart intersected by the ray. RaycastResult.Position | The world position where intersection took place. RaycastResult.Material | The material of BasePart intersected by the ray. RaycastResult.Normal | The vector perpendicular to the face of intersected surface. local origin = RedPart . Position local direction = ( GreenPart . Position - RedPart . Position ). Unit * 100 local RaycastParams = RaycastParams . new () RaycastParams . FilterDescendantsInstances = { RedPart } raycastParams . FilterType = Enum . RaycastFilterType . Blacklist local Raycast_result = workspace : Raycast ( origin , direction , raycastparams ) print ( Raycast_result . Position ) Warning Raycast_result will be nil if ray didn't hit any object. Now if we place another part between the two parts then ray will intersect the middle one and Raycast_result will carry properties related to the yellow part. Closing! As always, we hope you enjoyed reading and can utilize raycasting according to your needs. Whatever you are learning, please practice it on the spot. Just reading will not help you if you aren't practicing them. In case of any mistakes, typos, etc please report the article!","title":"Raycasting"},{"location":"Luau-Learning/RayCasting/#raycasting","text":"Roblox engine allows its users to cast an invisible ray from a Vector3 position towards a specified direction. Unlike normal rays, Roblox enables you to set the length of ray according to your needs. Using raycast, you can detect if the ray hits a Basepart or Terrain .","title":"Raycasting"},{"location":"Luau-Learning/RayCasting/#casting-a-ray","text":"For casting a ray we use the method :Raycast() of worldroot ( workspace ). Raycast() takes three arguments and returns RaycastResult Origin type: Vector3 Direction type: Vector3 RaycastParams type: RaycastParams local Raycast_result = workspace : Raycast ( origin , direction , raycastparams )","title":"Casting A Ray"},{"location":"Luau-Learning/RayCasting/#origin","text":"Origin of a ray is basically a Vector3 position of the world, from where the ray will start. We will take two parts . A red part and a green part and cast ray between them. local origin = RedPart . Position We have selected position of red part as origin for the ray.","title":"Origin"},{"location":"Luau-Learning/RayCasting/#direction","text":"Direction is the Vector3 with a defined magnitude. Direction of a ray from a known destination (GreenPart.Position) can be easily caluclated by using following formula Destination - Origin = Direction If you are familiar with vectors then we are basically getting a Vector3 between the two positions. Once we have calculated the directional vector, we will adjust the length of it. For doing so we will get the unit vector of directional vector and multiply it with the number of studs (the length of ray in studs). local direction = ( GreenPart . Position - RedPart . Position ). Unit * 100 In above example, the magnitude of ray is set to 100 studs.","title":"Direction"},{"location":"Luau-Learning/RayCasting/#raycastparams","text":"RaycastParams carries the parameters of Raycast() . It's property, FilterDescendantsInstances stores a table. It can be either a Blacklist or Whitelist depending on FilterType . Note Enum.RaycastFilterType.Whitelist Every BasePart other than those given in filter list and their descendants will be ignored. Enum.RaycastFilterType.Blacklist Every BasePart other than those given in filter list and their descendants will be considered. local RaycastParams = RaycastParams . new () RaycastParams . FilterDescendantsInstances = { RedPart } raycastParams . FilterType = Enum . RaycastFilterType . Blacklist In these params we have blacklisted the red part in order to prevent ray from being incident on the walls of red part. Our overall code will be: local origin = RedPart . Position local direction = ( GreenPart . Position - RedPart . Position ). Unit * 100 local RaycastParams = RaycastParams . new () RaycastParams . FilterDescendantsInstances = { RedPart } raycastParams . FilterType = Enum . RaycastFilterType . Blacklist local Raycast_result = workspace : Raycast ( origin , direction , raycastparams )","title":"RaycastParams"},{"location":"Luau-Learning/RayCasting/#raycastresult","text":"If the ray hits a basepart, it will return RaycastResult . It's properties carries result of raycast RaycastResult.Instance | The BasePart intersected by the ray. RaycastResult.Position | The world position where intersection took place. RaycastResult.Material | The material of BasePart intersected by the ray. RaycastResult.Normal | The vector perpendicular to the face of intersected surface. local origin = RedPart . Position local direction = ( GreenPart . Position - RedPart . Position ). Unit * 100 local RaycastParams = RaycastParams . new () RaycastParams . FilterDescendantsInstances = { RedPart } raycastParams . FilterType = Enum . RaycastFilterType . Blacklist local Raycast_result = workspace : Raycast ( origin , direction , raycastparams ) print ( Raycast_result . Position ) Warning Raycast_result will be nil if ray didn't hit any object. Now if we place another part between the two parts then ray will intersect the middle one and Raycast_result will carry properties related to the yellow part.","title":"RaycastResult"},{"location":"Luau-Learning/RayCasting/#closing","text":"As always, we hope you enjoyed reading and can utilize raycasting according to your needs. Whatever you are learning, please practice it on the spot. Just reading will not help you if you aren't practicing them. In case of any mistakes, typos, etc please report the article!","title":"Closing!"},{"location":"Luau-Learning/Remote_Events_And_Functions/","text":"Remote Events and Functions Roblox uses a client-server framework for handling multiplayer games. Roblox engine offers Remote Events and Remote Functions as a medium for communication between clients and server . The device of every player (such as mobile, console, pc) is considered a client . In a game, each client is connected to a Roblox computer called server . The server plays a major role in game management. During runtime, any changes made on the server are replicated to clients. For example, the position of a base part is changed using a server-side script. As the part changes its position, the server automatically updates every client, and every client changes the position of that part as well. This communication is done by the Roblox engine and developers don't have to care about replication. When designing a game, you will find multiple cases where either the server is contacting the client or the client is contacting the server. In such cases, you will have to use remote events or remote functions . For instance, A client wants to move an object. The server needs to warn any specific client for violating rules. For making in-server announcements. Communication between client and server can be either uni-directional or bi-directional. For uni-directional communication, we use remote events and remote functions for bi-directional. Remote Events. To use remote events, add a remote event in ReplictedStorage . Why replicated storage? Remote events and remote functions can only work when both the client and server can access them. ReplictedStorage serves as a perfect place for remotes. Every object placed in replicated storage is accessible to both the server and clients. As mentioned earlier, the remote event acts as a single pathway for communication. Here are some possible ways of using remote events. graph LR A[Client] --> B{Server}; graph LR A{Server} --> B[Client]; graph LR A{Server} --> B[All clients]; Client to Server When communicating from a client to the server we call the method RemoteEvent:FireServer() . You can transmit any number of information by passing them as arguments. Once fired from the client, a remote event can be received on the server by the event RemoteEvent.OnServerEvent . The function connected to OnServerEvent by default, receives the player who fired the event as the first parameter Example code: -- Script game . ReplicatedStorage . RemoteEvent . OnServerEvent : Connect ( function ( player , ...) print ( \"remote event received on server\" ) end ) -- Local script game . ReplicatedStorage . RemoteEvent : FireServer ( \"Eden my beloved\" ) Server to Client For server to client communication, we call the method RemoteEvent:FireClient() . The server itself can't determine, to whom you want to fire the remote event. You need to specify that client as the first argument of :FireClient() . RemoteEvent can be recieved on client by using RemoteEvent.OnClientEvent . Example Code: -- Local script game . ReplicatedStorage . RemoteEvent . OnClientEvent : Connect ( function ( player , ...) print ( \"remote event received on client\" ) end ) -- Script game . ReplicatedStorage . RemoteEvent : FireClient ( player , \"Eden my beloved\" ) Server to all Clients If you want to fire a remote from the server to all clients, you need to use RemoteEvent:FireAllClients() . In this case you are firing remote event to all clients which means you don't need to specify any client. Code Example: -- Local script game . ReplicatedStorage . RemoteEvent . OnClientEvent : Connect ( function ( player , ...) print ( \"remote event received on client\" ) end ) -- Script game . ReplicatedStorage . RemoteEvent : FireAllClients ( \"Eden my beloved\" ) Remote Functions As earlier, add a remote function in ReplicatedStorage Remote functions work similarly to remote events but as a bi-directional pathway. graph LR A[Client] --> B{Server}; B --> C[Client] graph LR A[Server] --> B{Client}; B --> C[Server] The remote function acts as a request and waits for the response and then returns. Client to Server A request can be made from a client to the server by RemoteFunction:InvokeServer() . On the server it can be received by binding a function to OnServerInvoke . Additional data can also be passed with RemoteFunction:InvokeServer() as arguments. Note The bounded function will receive player as the first parameter. Code Example: --script local function Request_Handler ( player , ...) print ( \"request recived\" ) return \"done!\" end game . ReplicatedStorage . RemoteFunction . OnServerInvoke = Request_Handler -- Local script game . ReplicatedStorage . RemoteFunction : InvokeServer ( \"hi\" ) Server To Client Request from the server to any client can be made using :InvokeClient() and received using .OnClientInvoke . However, it is highly recommended not to use it. Making a request from the server to any client can cause the breaking of your game. Because of the following risks If a client got disconnected while being invoked. The invoke call will error. If a client never returned any value, the server will never stop waiting for it. If the client throws an error, the server will pass the error too. Limitation Any non-string elements of a table passed either using a remote event or remote function will be converted into a string. Any instance that exists only on a client will be nil on the server. Closing! We hope you enjoyed. Whatever you are learning, please practice it on the spot. Just reading will not help you if you aren't practicing them. In case of any mistakes, typos, etc please report the article!","title":"Remote Events and Functions"},{"location":"Luau-Learning/Remote_Events_And_Functions/#remote-events-and-functions","text":"Roblox uses a client-server framework for handling multiplayer games. Roblox engine offers Remote Events and Remote Functions as a medium for communication between clients and server . The device of every player (such as mobile, console, pc) is considered a client . In a game, each client is connected to a Roblox computer called server . The server plays a major role in game management. During runtime, any changes made on the server are replicated to clients. For example, the position of a base part is changed using a server-side script. As the part changes its position, the server automatically updates every client, and every client changes the position of that part as well. This communication is done by the Roblox engine and developers don't have to care about replication. When designing a game, you will find multiple cases where either the server is contacting the client or the client is contacting the server. In such cases, you will have to use remote events or remote functions . For instance, A client wants to move an object. The server needs to warn any specific client for violating rules. For making in-server announcements. Communication between client and server can be either uni-directional or bi-directional. For uni-directional communication, we use remote events and remote functions for bi-directional.","title":"Remote Events and Functions"},{"location":"Luau-Learning/Remote_Events_And_Functions/#remote-events","text":"To use remote events, add a remote event in ReplictedStorage . Why replicated storage? Remote events and remote functions can only work when both the client and server can access them. ReplictedStorage serves as a perfect place for remotes. Every object placed in replicated storage is accessible to both the server and clients. As mentioned earlier, the remote event acts as a single pathway for communication. Here are some possible ways of using remote events. graph LR A[Client] --> B{Server}; graph LR A{Server} --> B[Client]; graph LR A{Server} --> B[All clients];","title":"Remote Events."},{"location":"Luau-Learning/Remote_Events_And_Functions/#client-to-server","text":"When communicating from a client to the server we call the method RemoteEvent:FireServer() . You can transmit any number of information by passing them as arguments. Once fired from the client, a remote event can be received on the server by the event RemoteEvent.OnServerEvent . The function connected to OnServerEvent by default, receives the player who fired the event as the first parameter Example code: -- Script game . ReplicatedStorage . RemoteEvent . OnServerEvent : Connect ( function ( player , ...) print ( \"remote event received on server\" ) end ) -- Local script game . ReplicatedStorage . RemoteEvent : FireServer ( \"Eden my beloved\" )","title":"Client to Server"},{"location":"Luau-Learning/Remote_Events_And_Functions/#server-to-client","text":"For server to client communication, we call the method RemoteEvent:FireClient() . The server itself can't determine, to whom you want to fire the remote event. You need to specify that client as the first argument of :FireClient() . RemoteEvent can be recieved on client by using RemoteEvent.OnClientEvent . Example Code: -- Local script game . ReplicatedStorage . RemoteEvent . OnClientEvent : Connect ( function ( player , ...) print ( \"remote event received on client\" ) end ) -- Script game . ReplicatedStorage . RemoteEvent : FireClient ( player , \"Eden my beloved\" )","title":"Server to Client"},{"location":"Luau-Learning/Remote_Events_And_Functions/#server-to-all-clients","text":"If you want to fire a remote from the server to all clients, you need to use RemoteEvent:FireAllClients() . In this case you are firing remote event to all clients which means you don't need to specify any client. Code Example: -- Local script game . ReplicatedStorage . RemoteEvent . OnClientEvent : Connect ( function ( player , ...) print ( \"remote event received on client\" ) end ) -- Script game . ReplicatedStorage . RemoteEvent : FireAllClients ( \"Eden my beloved\" )","title":"Server to all Clients"},{"location":"Luau-Learning/Remote_Events_And_Functions/#remote-functions","text":"As earlier, add a remote function in ReplicatedStorage Remote functions work similarly to remote events but as a bi-directional pathway. graph LR A[Client] --> B{Server}; B --> C[Client] graph LR A[Server] --> B{Client}; B --> C[Server] The remote function acts as a request and waits for the response and then returns.","title":"Remote Functions"},{"location":"Luau-Learning/Remote_Events_And_Functions/#client-to-server_1","text":"A request can be made from a client to the server by RemoteFunction:InvokeServer() . On the server it can be received by binding a function to OnServerInvoke . Additional data can also be passed with RemoteFunction:InvokeServer() as arguments. Note The bounded function will receive player as the first parameter. Code Example: --script local function Request_Handler ( player , ...) print ( \"request recived\" ) return \"done!\" end game . ReplicatedStorage . RemoteFunction . OnServerInvoke = Request_Handler -- Local script game . ReplicatedStorage . RemoteFunction : InvokeServer ( \"hi\" )","title":"Client to Server"},{"location":"Luau-Learning/Remote_Events_And_Functions/#server-to-client_1","text":"Request from the server to any client can be made using :InvokeClient() and received using .OnClientInvoke . However, it is highly recommended not to use it. Making a request from the server to any client can cause the breaking of your game. Because of the following risks If a client got disconnected while being invoked. The invoke call will error. If a client never returned any value, the server will never stop waiting for it. If the client throws an error, the server will pass the error too.","title":"Server To Client"},{"location":"Luau-Learning/Remote_Events_And_Functions/#limitation","text":"Any non-string elements of a table passed either using a remote event or remote function will be converted into a string. Any instance that exists only on a client will be nil on the server.","title":"Limitation"},{"location":"Luau-Learning/Remote_Events_And_Functions/#closing","text":"We hope you enjoyed. Whatever you are learning, please practice it on the spot. Just reading will not help you if you aren't practicing them. In case of any mistakes, typos, etc please report the article!","title":"Closing!"},{"location":"Luau-Learning/Scripts_and_Local_scripts/","text":"Script Script is an object that contains Lua code. Normally a script is used for server-side code execution. It has excess to almost all the objects, properties of data model. It can also run if it's parent property is set to nil. In order to insert a script, click the + icon next to the desired instance in explorer window. Every script by default has a command print ( \"Hello World!\" ) Local Scripts Local script also carries Lua code however they are used for client-side code execution. Local scripts only run when they are descendant of any of the following objects: PlayerScripts Backpack PlayerGui Character ReplicatedFirst Basically when local script is placed in any of them, it is replicated to every player. This means local script runs on every client separately and every client has their own local scripts. Mainly local scripts are used to access client only objects such as input, camera, etc. Essentially local scripts are able to access the client running them by using LocalPlayer property of Players . Local script can be added in the same way as normal script. Closing! I hope, now you have a basic understanding of local script and a normal script. If you find any typos, or any sort of flaws then please report it here","title":"Scripts and Local scripts"},{"location":"Luau-Learning/Scripts_and_Local_scripts/#script","text":"Script is an object that contains Lua code. Normally a script is used for server-side code execution. It has excess to almost all the objects, properties of data model. It can also run if it's parent property is set to nil. In order to insert a script, click the + icon next to the desired instance in explorer window. Every script by default has a command print ( \"Hello World!\" )","title":"Script"},{"location":"Luau-Learning/Scripts_and_Local_scripts/#local-scripts","text":"Local script also carries Lua code however they are used for client-side code execution. Local scripts only run when they are descendant of any of the following objects: PlayerScripts Backpack PlayerGui Character ReplicatedFirst Basically when local script is placed in any of them, it is replicated to every player. This means local script runs on every client separately and every client has their own local scripts. Mainly local scripts are used to access client only objects such as input, camera, etc. Essentially local scripts are able to access the client running them by using LocalPlayer property of Players . Local script can be added in the same way as normal script.","title":"Local Scripts"},{"location":"Luau-Learning/Scripts_and_Local_scripts/#closing","text":"I hope, now you have a basic understanding of local script and a normal script. If you find any typos, or any sort of flaws then please report it here","title":"Closing!"},{"location":"Luau-Learning/Strings/","text":"String Strings are an important part of programming and are used in many high-level programming languages. A string is a combination of alphabetical letters, numbers, and other symbols. Declaring String Strings can be declared in numerous ways however the most commonly used are by using double quotes(\") and single quotes('). local str = \"EdenRose\" local user = 'EdenRose#1968' Multi-line String A Multi-line string can be declared by using double brackets ( [[ ) local str = [[Helpers of Rodevs are very skilled. They help a lot in development channels.]] local str2 = [[Helpers are the pride of Rodevs. They spend their free time helping out others. :) ]] Concatenation Concatenation is as method by using which we can combine two strings, for doing so we use \" .. \" between both the strings. Code Output local str1 = \"I am \" local str2 = \"EdenRose\" print ( str1 .. str2 ) I am EdenRose String Escaping In a string declared with (\") or ('), You can produce almost any character using ( \\ ). It can be used in many ways such as having quotes inside a string without disturbing it, printing in a new line, etc. Code Output print ( \"Greetings \\\" Rodevs \\\" \" ) print ( \"First line \\n Second line) Greetings \"Rodevs\" First line Second line Arithmetic With Strings When using arithmetic operators between strings, Lua tends to convert the string into a number. Code Output print ( \"7\" + \"22\" ) print ( \"17\" - 4 ) 29 13 Warning If Lua failed to convert any string such as \"Rose\" then it will return an error causing termination of the thread. Conversion A string can be converted into a number by simply using tonumber() , a global function of Lua. Code Output print ( tonumber ( \"78\" )) print ( tonumber ( \"hola\" )) 78 nil Similarly, a number can also be converted into a string by the function tostring() Code Output print ( tostring ( 78 )) 78 Closing I hope you had a good time reading this. In case of any mistake please report the article.","title":"String"},{"location":"Luau-Learning/Strings/#string","text":"Strings are an important part of programming and are used in many high-level programming languages. A string is a combination of alphabetical letters, numbers, and other symbols.","title":"String"},{"location":"Luau-Learning/Strings/#declaring-string","text":"Strings can be declared in numerous ways however the most commonly used are by using double quotes(\") and single quotes('). local str = \"EdenRose\" local user = 'EdenRose#1968'","title":"Declaring String"},{"location":"Luau-Learning/Strings/#multi-line-string","text":"A Multi-line string can be declared by using double brackets ( [[ ) local str = [[Helpers of Rodevs are very skilled. They help a lot in development channels.]] local str2 = [[Helpers are the pride of Rodevs. They spend their free time helping out others. :) ]]","title":"Multi-line String"},{"location":"Luau-Learning/Strings/#concatenation","text":"Concatenation is as method by using which we can combine two strings, for doing so we use \" .. \" between both the strings. Code Output local str1 = \"I am \" local str2 = \"EdenRose\" print ( str1 .. str2 ) I am EdenRose","title":"Concatenation"},{"location":"Luau-Learning/Strings/#string-escaping","text":"In a string declared with (\") or ('), You can produce almost any character using ( \\ ). It can be used in many ways such as having quotes inside a string without disturbing it, printing in a new line, etc. Code Output print ( \"Greetings \\\" Rodevs \\\" \" ) print ( \"First line \\n Second line) Greetings \"Rodevs\" First line Second line","title":"String Escaping"},{"location":"Luau-Learning/Strings/#arithmetic-with-strings","text":"When using arithmetic operators between strings, Lua tends to convert the string into a number. Code Output print ( \"7\" + \"22\" ) print ( \"17\" - 4 ) 29 13 Warning If Lua failed to convert any string such as \"Rose\" then it will return an error causing termination of the thread.","title":"Arithmetic With Strings"},{"location":"Luau-Learning/Strings/#conversion","text":"A string can be converted into a number by simply using tonumber() , a global function of Lua. Code Output print ( tonumber ( \"78\" )) print ( tonumber ( \"hola\" )) 78 nil Similarly, a number can also be converted into a string by the function tostring() Code Output print ( tostring ( 78 )) 78","title":"Conversion"},{"location":"Luau-Learning/Strings/#closing","text":"I hope you had a good time reading this. In case of any mistake please report the article.","title":"Closing"},{"location":"Luau-Learning/Tables/","text":"Understanding the Basics of Tables One of the things you're going to be doing a lot when scripting is handling data and values: strings , numbers , booleans , etc. Wouldn't it be nice to have a way \u201cencapsulate\u201d or \u201cgroup\u201d that data together into one single data type? Introducing tables! Tables let you group data into a single data type. This makes it easier to work with and manipulate data. Constructing/Creating Tables The simplest way to construct a table is by using curly braces {} , like this: local my_table = {} In Luau, there are 2 kinds of tables: arrays and dictionaries. Arrays are basically lists, like a grocery list or a list of players in a game. Dictionaries are like\u2026 well\u2026 actual dictionaries! It'll make sense later, I swear! Arrays Arrays use numbers as its indices (known as indexes). Arrays are very useful when it comes to grouping a collection of data, like a group of players that are online or a group of admins in a game. Constructing Arrays To construct an array, simply declare the values you'd like to put in curly braces {} separated by commas , : local top_5_friends = { \"Eden\" , \"Joe\" , \"John\" , \"Teerach\" , \"Shogus\" } Reading Arrays Now, say we want to see who's first in our \u201cTop 5 Friends\u201d list. All we need to do is add square brackets [] after our top_5_friends variable and the entry's position [position] . In our case, that position will be 1 since we're checking who's first. local top_5_friends = { \"Eden\" , \"Joe\" , \"John\" , \"Teerach\" , \"Shogus\" } print ( top_5_friends [ 1 ]) -- ^ prints \"Eden\" Info Unlike other languages, arrays in Luau start at 1 instead of 0 . If we were to do the same thing in another language, for example Ruby, we'd have to do: top_5_friends [ 0 ] Writing Into Arrays To append a new entry to an array, we can use a method from Luau's table library called insert . Call the method and pass our array's reference (top_5_friends) and the value we want to append: local top_5_friends = { \"Eden\" , \"Joe\" , \"John\" , \"Teerach\" , \"Shogus\" } table.insert ( top_5_friends , \"Willie\" ) print ( top_5_friends [ 6 ]) -- we check the 6th entry because our array has 6 entries -- ^ prints \"Willie\" You can also specify where to append by passing in a number when calling table.insert . But remember, this method will shift any following entries up by one position: local top_5_friends = { \"Eden\" , \"Joe\" , \"John\" , \"Teerach\" , \"Shogus\" } print ( top_5_friends [ 2 ]) -- ^ prints \"Joe\" print ( top_5_friends [ 3 ]) -- ^ prints \"John\" table.insert ( top_5_friends , 2 , \"Willie\" ) print ( top_5_friends [ 2 ]) -- ^ prints \"Willie\" print ( top_5_friends [ 3 ]) -- ^ prints \"Joe\" -- the method shifted \"Joe\" from 2nd to 3rd To overwrite an array's entry, simply put the entry's position in square brackets [position] followed by = and the new value: local list = { \"John\" , \"Jonathan\" , \"Joe\" } print ( list [ 3 ]) -- ^ prints \"Joe\" list [ 3 ] = \"Jon\" print ( list [ 3 ]) -- ^ prints \"Jon\" Deleting Entries For deleting entries, we can use another method from the table library called remove . This method will remove the specified entry and also shifts any following entries one position down. Simply call the method and pass the array's reference and the position of the entry you'd like removed: local list = { \"Eden\" , \"Gato\" , \"Teerach\" } print ( list [ 2 ]) -- ^ prints \"Gato\" table.remove ( list , 2 ) print ( list [ 2 ]) -- ^ prints \"Teerach\" -- table.remove moved \"Teerach\" from 3rd to 2nd Dictionaries Like I said earlier, dictionaries in Luau are like actual dictionaries. To prove my point, we're going to invent our own language called \u201cHelperin\u201d and we're going to make a \u201cHelperin Dictionary\u201d . To start off, we're going to add 2 words to our \u201cHelperin Dictionary\u201d : \u201cDev Mute\u201d and \u201cOff-topic\u201d . This is what our dictionary is going to look like: Dev Mute = To mute someone for breaking the guidelines. Off-topic = Talking about topics not relevant to the channel's purpose Simple enough right? Now, unlike arrays, a dictionary's indices (known as keys) can be literally anything: strings , numbers , functions , etc. For this article, we're going to be using strings exclusively. Mainly because it's the easiest to understand and the simplest one to use. Constructing Dictionaries To construct a dictionary, simply declare each key followed by = and the value. Don't forget to separate each key-value pair with commas! , . Let's make our \"Helperin Dictionary\" ! local helperin_dictionary = { [ \"Dev Mute\" ] = \"To mute someone for breaking the guidelines\" , [ \"Off-topic\" ] = \"Talking about topics not relevant to the channel's purpose\" , } Reading Dictionaries Reading from dictionaries is quite simple, add a pair of square brackets [] after your dictionary's reference, and inside it, specify the key you want to read from reference[key] : local helperin_dictionary = { [ \"Dev Mute\" ] = \"To mute someone for breaking the guidelines\" , [ \"Off-topic\" ] = \"Talking about topics not relevant to the channel's purpose\" , } print ( helperin_dictionary [ \"Dev Mute\" ]) -- ^ prints \"To mute someone for breaking the guidelines\" Or if you have a variable: local helperin_dictionary = { [ \"Dev Mute\" ] = \"To mute someone for breaking the guidelines\" , [ \"Off-topic\" ] = \"Talking about topics not relevant to the channel's purpose\" , } local word = \"Off-topic\" print ( helperin_dictionary [ word ]) -- ^ prints \"Talking about topics not relevant to the channel's purpose\" Writing into Dictionaries Now, I want to add a new word to our \u201cHelperin Dictionary\u201d . To add a new entry to a dictionary, specify the key you want to add followed by = and the new value: local helperin_dictionary = { [ \"Dev Mute\" ] = \"To mute someone for breaking the guidelines\" , [ \"Off-topic\" ] = \"Talking about topics not relevant to the channel's purpose\" , } helperin_dictionary [ \">tag joe\" ] = \"A humorous image designed to bully every beginner in existence\" print ( helperin_dictionary [ \">tag joe\" ]) -- ^ prints \"A humorous image designed to bully every beginner in existence\" If you want to overwrite an entry in your dictionary, simply do what you just previously did (yes, really): local helperin_dictionary = { [ \"Dev Mute\" ] = \"To mute someone for breaking the guidelines\" , [ \"Off-topic\" ] = \"Talking about topics not relevant to the channel's purpose\" , [ \">tag joe\" ] = \"A humorous image designed to bully every beginner in existence\" } print ( helperin_dictionary [ \"Dev Mute\" ]) -- ^ prints \"To mute someone for breaking the guidelines\" helperin_dictionary [ \"Dev Mute\" ] = \"Muting someone from the development category\" print ( helperin_dictionary [ \"Dev Mute\" ]) -- ^ prints \"Muting someone from the development category\" Removing Entries Removing an entry is the same as writing into dictionaries, but instead of assigning a new value to the key, you assign nil . Doing this will remove the entry from your dictionary: local helperin_dictionary = { [ \"Dev Mute\" ] = \"To mute someone for breaking the guidelines\" , [ \"Off-topic\" ] = \"Talking about topics not relevant to the channel's purpose\" , [ \">tag joe\" ] = \"A humorous image designed to bully every beginner in existence\" } helperin_dictionary [ \"Dev Mute\" ] = nil print ( helperin_dictionary [ \"Dev Mute\" ]) -- ^ prints nil Iterating Through Tables Reading a single entry of a table is cool and all, but reading all the entries is cooler. We can do this by iterating through the table using Luau's generalized iterator. Luau's generalized iterator looks like this: for index , value in table_name do end Now, if we want to iterate through an array or a dictionary, we can just use this generalized iterator to do it: local friends_list = { \"Eden\" , \"Willi\" , \"Shogus\" } for index , friend in friends_list do print ( \"Hello! \" .. friend ) end -- ^ prints: -- Hello! Eden -- Hello! Willi -- Hello! Shogus local student_math_test_scores = { [ \"John\" ] = 98 , [ \"Laura\" ] = 80 , [ \"Janet\" ] = 78 , [ \"Larry\" ] = 40 } for student , score in student_math_test_scores do print ( student .. \": \" .. score ) end -- ^ prints -- Laura: 80 -- Janet: 78 -- John: 98 -- Larry: 40 Or you can use good ol' iterator functions: pairs() and ipairs() . pairs() for dictionaries, and ipairs() for arrays. local friends_list = { \"Eden\" , \"Willi\" , \"Shogus\" } for index , friend in ipairs ( friends_list ) do print ( \"Hello! \" .. friend ) end -- ^ prints: -- Hello! Eden -- Hello! Willi -- Hello! Shogus local student_math_test_scores = { [ \"John\" ] = 98 , [ \"Laura\" ] = 80 , [ \"Janet\" ] = 78 , [ \"Larry\" ] = 40 } for student , score in pairs ( student_math_test_scores ) do print ( student .. \": \" .. score ) end -- ^ prints -- Laura: 80 -- Janet: 78 -- John: 98 -- Larry: 40 THERE'S NO ORDER?! When iterating through dictionaries, you might've realized that it's not ordered correctly. This is because there's no sense of order in dictionaries, unlike arrays which are ordered lists. So be wary of that next time you iterate through a dictionary! Challenges (Optional) Here's a fun challenge! Remember the \"Helperin Dictionary\u201d ? I want you to add new words, edit definitions of existing words, and delete some entries. Personalize it to your liking! local helperin_dictionary = { [ \"Dev Mute\" ] = \"To mute someone for breaking the guidelines\" , [ \"Off-topic\" ] = \"Talking about topics not relevant to the channel's purpose\" , [ \">tag joe\" ] = \"A humorous image designed to bully every beginner in existence\" } Closing Ayo! Thanks for reading! If there are any mistakes, or maybe you felt like something was missing, report it ! If you have some free time, perhaps leave us a review ! Your feedback means a lot to us and helps us improve our site.","title":"Understanding the Basics of Tables"},{"location":"Luau-Learning/Tables/#understanding-the-basics-of-tables","text":"One of the things you're going to be doing a lot when scripting is handling data and values: strings , numbers , booleans , etc. Wouldn't it be nice to have a way \u201cencapsulate\u201d or \u201cgroup\u201d that data together into one single data type? Introducing tables! Tables let you group data into a single data type. This makes it easier to work with and manipulate data.","title":"Understanding the Basics of Tables"},{"location":"Luau-Learning/Tables/#constructingcreating-tables","text":"The simplest way to construct a table is by using curly braces {} , like this: local my_table = {} In Luau, there are 2 kinds of tables: arrays and dictionaries. Arrays are basically lists, like a grocery list or a list of players in a game. Dictionaries are like\u2026 well\u2026 actual dictionaries! It'll make sense later, I swear!","title":"Constructing/Creating Tables"},{"location":"Luau-Learning/Tables/#arrays","text":"Arrays use numbers as its indices (known as indexes). Arrays are very useful when it comes to grouping a collection of data, like a group of players that are online or a group of admins in a game.","title":"Arrays"},{"location":"Luau-Learning/Tables/#constructing-arrays","text":"To construct an array, simply declare the values you'd like to put in curly braces {} separated by commas , : local top_5_friends = { \"Eden\" , \"Joe\" , \"John\" , \"Teerach\" , \"Shogus\" }","title":"Constructing Arrays"},{"location":"Luau-Learning/Tables/#reading-arrays","text":"Now, say we want to see who's first in our \u201cTop 5 Friends\u201d list. All we need to do is add square brackets [] after our top_5_friends variable and the entry's position [position] . In our case, that position will be 1 since we're checking who's first. local top_5_friends = { \"Eden\" , \"Joe\" , \"John\" , \"Teerach\" , \"Shogus\" } print ( top_5_friends [ 1 ]) -- ^ prints \"Eden\" Info Unlike other languages, arrays in Luau start at 1 instead of 0 . If we were to do the same thing in another language, for example Ruby, we'd have to do: top_5_friends [ 0 ]","title":"Reading Arrays"},{"location":"Luau-Learning/Tables/#writing-into-arrays","text":"To append a new entry to an array, we can use a method from Luau's table library called insert . Call the method and pass our array's reference (top_5_friends) and the value we want to append: local top_5_friends = { \"Eden\" , \"Joe\" , \"John\" , \"Teerach\" , \"Shogus\" } table.insert ( top_5_friends , \"Willie\" ) print ( top_5_friends [ 6 ]) -- we check the 6th entry because our array has 6 entries -- ^ prints \"Willie\" You can also specify where to append by passing in a number when calling table.insert . But remember, this method will shift any following entries up by one position: local top_5_friends = { \"Eden\" , \"Joe\" , \"John\" , \"Teerach\" , \"Shogus\" } print ( top_5_friends [ 2 ]) -- ^ prints \"Joe\" print ( top_5_friends [ 3 ]) -- ^ prints \"John\" table.insert ( top_5_friends , 2 , \"Willie\" ) print ( top_5_friends [ 2 ]) -- ^ prints \"Willie\" print ( top_5_friends [ 3 ]) -- ^ prints \"Joe\" -- the method shifted \"Joe\" from 2nd to 3rd To overwrite an array's entry, simply put the entry's position in square brackets [position] followed by = and the new value: local list = { \"John\" , \"Jonathan\" , \"Joe\" } print ( list [ 3 ]) -- ^ prints \"Joe\" list [ 3 ] = \"Jon\" print ( list [ 3 ]) -- ^ prints \"Jon\"","title":"Writing Into Arrays"},{"location":"Luau-Learning/Tables/#deleting-entries","text":"For deleting entries, we can use another method from the table library called remove . This method will remove the specified entry and also shifts any following entries one position down. Simply call the method and pass the array's reference and the position of the entry you'd like removed: local list = { \"Eden\" , \"Gato\" , \"Teerach\" } print ( list [ 2 ]) -- ^ prints \"Gato\" table.remove ( list , 2 ) print ( list [ 2 ]) -- ^ prints \"Teerach\" -- table.remove moved \"Teerach\" from 3rd to 2nd","title":"Deleting Entries"},{"location":"Luau-Learning/Tables/#dictionaries","text":"Like I said earlier, dictionaries in Luau are like actual dictionaries. To prove my point, we're going to invent our own language called \u201cHelperin\u201d and we're going to make a \u201cHelperin Dictionary\u201d . To start off, we're going to add 2 words to our \u201cHelperin Dictionary\u201d : \u201cDev Mute\u201d and \u201cOff-topic\u201d . This is what our dictionary is going to look like: Dev Mute = To mute someone for breaking the guidelines. Off-topic = Talking about topics not relevant to the channel's purpose Simple enough right? Now, unlike arrays, a dictionary's indices (known as keys) can be literally anything: strings , numbers , functions , etc. For this article, we're going to be using strings exclusively. Mainly because it's the easiest to understand and the simplest one to use.","title":"Dictionaries"},{"location":"Luau-Learning/Tables/#constructing-dictionaries","text":"To construct a dictionary, simply declare each key followed by = and the value. Don't forget to separate each key-value pair with commas! , . Let's make our \"Helperin Dictionary\" ! local helperin_dictionary = { [ \"Dev Mute\" ] = \"To mute someone for breaking the guidelines\" , [ \"Off-topic\" ] = \"Talking about topics not relevant to the channel's purpose\" , }","title":"Constructing Dictionaries"},{"location":"Luau-Learning/Tables/#reading-dictionaries","text":"Reading from dictionaries is quite simple, add a pair of square brackets [] after your dictionary's reference, and inside it, specify the key you want to read from reference[key] : local helperin_dictionary = { [ \"Dev Mute\" ] = \"To mute someone for breaking the guidelines\" , [ \"Off-topic\" ] = \"Talking about topics not relevant to the channel's purpose\" , } print ( helperin_dictionary [ \"Dev Mute\" ]) -- ^ prints \"To mute someone for breaking the guidelines\" Or if you have a variable: local helperin_dictionary = { [ \"Dev Mute\" ] = \"To mute someone for breaking the guidelines\" , [ \"Off-topic\" ] = \"Talking about topics not relevant to the channel's purpose\" , } local word = \"Off-topic\" print ( helperin_dictionary [ word ]) -- ^ prints \"Talking about topics not relevant to the channel's purpose\"","title":"Reading Dictionaries"},{"location":"Luau-Learning/Tables/#writing-into-dictionaries","text":"Now, I want to add a new word to our \u201cHelperin Dictionary\u201d . To add a new entry to a dictionary, specify the key you want to add followed by = and the new value: local helperin_dictionary = { [ \"Dev Mute\" ] = \"To mute someone for breaking the guidelines\" , [ \"Off-topic\" ] = \"Talking about topics not relevant to the channel's purpose\" , } helperin_dictionary [ \">tag joe\" ] = \"A humorous image designed to bully every beginner in existence\" print ( helperin_dictionary [ \">tag joe\" ]) -- ^ prints \"A humorous image designed to bully every beginner in existence\" If you want to overwrite an entry in your dictionary, simply do what you just previously did (yes, really): local helperin_dictionary = { [ \"Dev Mute\" ] = \"To mute someone for breaking the guidelines\" , [ \"Off-topic\" ] = \"Talking about topics not relevant to the channel's purpose\" , [ \">tag joe\" ] = \"A humorous image designed to bully every beginner in existence\" } print ( helperin_dictionary [ \"Dev Mute\" ]) -- ^ prints \"To mute someone for breaking the guidelines\" helperin_dictionary [ \"Dev Mute\" ] = \"Muting someone from the development category\" print ( helperin_dictionary [ \"Dev Mute\" ]) -- ^ prints \"Muting someone from the development category\"","title":"Writing into Dictionaries"},{"location":"Luau-Learning/Tables/#removing-entries","text":"Removing an entry is the same as writing into dictionaries, but instead of assigning a new value to the key, you assign nil . Doing this will remove the entry from your dictionary: local helperin_dictionary = { [ \"Dev Mute\" ] = \"To mute someone for breaking the guidelines\" , [ \"Off-topic\" ] = \"Talking about topics not relevant to the channel's purpose\" , [ \">tag joe\" ] = \"A humorous image designed to bully every beginner in existence\" } helperin_dictionary [ \"Dev Mute\" ] = nil print ( helperin_dictionary [ \"Dev Mute\" ]) -- ^ prints nil","title":"Removing Entries"},{"location":"Luau-Learning/Tables/#iterating-through-tables","text":"Reading a single entry of a table is cool and all, but reading all the entries is cooler. We can do this by iterating through the table using Luau's generalized iterator. Luau's generalized iterator looks like this: for index , value in table_name do end Now, if we want to iterate through an array or a dictionary, we can just use this generalized iterator to do it: local friends_list = { \"Eden\" , \"Willi\" , \"Shogus\" } for index , friend in friends_list do print ( \"Hello! \" .. friend ) end -- ^ prints: -- Hello! Eden -- Hello! Willi -- Hello! Shogus local student_math_test_scores = { [ \"John\" ] = 98 , [ \"Laura\" ] = 80 , [ \"Janet\" ] = 78 , [ \"Larry\" ] = 40 } for student , score in student_math_test_scores do print ( student .. \": \" .. score ) end -- ^ prints -- Laura: 80 -- Janet: 78 -- John: 98 -- Larry: 40 Or you can use good ol' iterator functions: pairs() and ipairs() . pairs() for dictionaries, and ipairs() for arrays. local friends_list = { \"Eden\" , \"Willi\" , \"Shogus\" } for index , friend in ipairs ( friends_list ) do print ( \"Hello! \" .. friend ) end -- ^ prints: -- Hello! Eden -- Hello! Willi -- Hello! Shogus local student_math_test_scores = { [ \"John\" ] = 98 , [ \"Laura\" ] = 80 , [ \"Janet\" ] = 78 , [ \"Larry\" ] = 40 } for student , score in pairs ( student_math_test_scores ) do print ( student .. \": \" .. score ) end -- ^ prints -- Laura: 80 -- Janet: 78 -- John: 98 -- Larry: 40 THERE'S NO ORDER?! When iterating through dictionaries, you might've realized that it's not ordered correctly. This is because there's no sense of order in dictionaries, unlike arrays which are ordered lists. So be wary of that next time you iterate through a dictionary!","title":"Iterating Through Tables"},{"location":"Luau-Learning/Tables/#challenges-optional","text":"Here's a fun challenge! Remember the \"Helperin Dictionary\u201d ? I want you to add new words, edit definitions of existing words, and delete some entries. Personalize it to your liking! local helperin_dictionary = { [ \"Dev Mute\" ] = \"To mute someone for breaking the guidelines\" , [ \"Off-topic\" ] = \"Talking about topics not relevant to the channel's purpose\" , [ \">tag joe\" ] = \"A humorous image designed to bully every beginner in existence\" }","title":"Challenges (Optional)"},{"location":"Luau-Learning/Tables/#closing","text":"Ayo! Thanks for reading! If there are any mistakes, or maybe you felt like something was missing, report it ! If you have some free time, perhaps leave us a review ! Your feedback means a lot to us and helps us improve our site.","title":"Closing"},{"location":"Luau-Learning/Tool/","text":"Tools As the name suggests, tools are the objects with which players can interact. Tools are equipped by the Humanoid of the player's character. Usually, tools are stored in the player's Backpack . When a tool is equipped, it is moved from Backpack to the player's Character . This means parenting a tool to the player's Character forces the character to equip it. However Roblox also offers methods Humanoid:EquipTool() and Humanoid:UnequipTools() for this purpose. Every tool requires a BasePart named Handle as a child of it unless the property Tool.RequiresHandle is set to false . Creating A Tool Add a part in the workspace. Change its shape and color to whatever you like. Name the part as \"Handle\" . Click the (+) icon next to workspace and add a Tool in it. Parent the Handle to the Tool . Now place tool inside StarterPack . When the game runs, all the tools in StarterPack are replicated to the player's Backpack . Now, if you run the game, you can see a tool in your inventory. Setting Grips the grip of a tool can be adjusted by changing the following properties: However there is an amazing plugin, you can use for adjusting grips Tool Grip Editor Scripting Tool As most of the objects, a tool can be fully utilized by scripting it. Insert a LocalScript in the tool. When a tool is equipped, the event Equipped is fired. Example Code: script . Parent . Equipped : Connect ( function () print ( \"Tool got equipped\" ) end ) Note script is a Roblox global which carries the reference of current Script or LocalScript . Equipped event returns Mouse object. Because it is deprecated, we will not cover it in this guide. Similarly, Tool.Unequipped is fired. Example Code: script . Parent . Unequipped : Connect ( function () print ( \"Tool got unequipped\" ) end ) It is not just limited to equipped and unequipped. Roblox engine also offers Activated and Deactivated which are fired when a player activates (click/tap while the tool is equipped) and deactivates (left mouse button is released) respectively. Example Code: script . Parent . Activated : Connect ( function () print ( \"Tool is being used\" ) end ) script . Parent . Deactivated : Connect ( function () print ( \"Tool is no longer being used\" ) end ) These are the only events of tools other than those inherited from instance . Additionals Roblox's Offical Api Refernce Of Tools Closing! That's pretty much of it. Hope you enjoyed reading it. In case of any mistake, typos, etc. Please report the article. You can also give us reviews here","title":"Tools"},{"location":"Luau-Learning/Tool/#tools","text":"As the name suggests, tools are the objects with which players can interact. Tools are equipped by the Humanoid of the player's character. Usually, tools are stored in the player's Backpack . When a tool is equipped, it is moved from Backpack to the player's Character . This means parenting a tool to the player's Character forces the character to equip it. However Roblox also offers methods Humanoid:EquipTool() and Humanoid:UnequipTools() for this purpose. Every tool requires a BasePart named Handle as a child of it unless the property Tool.RequiresHandle is set to false .","title":"Tools"},{"location":"Luau-Learning/Tool/#creating-a-tool","text":"Add a part in the workspace. Change its shape and color to whatever you like. Name the part as \"Handle\" . Click the (+) icon next to workspace and add a Tool in it. Parent the Handle to the Tool . Now place tool inside StarterPack . When the game runs, all the tools in StarterPack are replicated to the player's Backpack . Now, if you run the game, you can see a tool in your inventory.","title":"Creating A Tool"},{"location":"Luau-Learning/Tool/#setting-grips","text":"the grip of a tool can be adjusted by changing the following properties: However there is an amazing plugin, you can use for adjusting grips Tool Grip Editor","title":"Setting Grips"},{"location":"Luau-Learning/Tool/#scripting-tool","text":"As most of the objects, a tool can be fully utilized by scripting it. Insert a LocalScript in the tool. When a tool is equipped, the event Equipped is fired. Example Code: script . Parent . Equipped : Connect ( function () print ( \"Tool got equipped\" ) end ) Note script is a Roblox global which carries the reference of current Script or LocalScript . Equipped event returns Mouse object. Because it is deprecated, we will not cover it in this guide. Similarly, Tool.Unequipped is fired. Example Code: script . Parent . Unequipped : Connect ( function () print ( \"Tool got unequipped\" ) end ) It is not just limited to equipped and unequipped. Roblox engine also offers Activated and Deactivated which are fired when a player activates (click/tap while the tool is equipped) and deactivates (left mouse button is released) respectively. Example Code: script . Parent . Activated : Connect ( function () print ( \"Tool is being used\" ) end ) script . Parent . Deactivated : Connect ( function () print ( \"Tool is no longer being used\" ) end ) These are the only events of tools other than those inherited from instance .","title":"Scripting Tool"},{"location":"Luau-Learning/Tool/#additionals","text":"Roblox's Offical Api Refernce Of Tools","title":"Additionals"},{"location":"Luau-Learning/Tool/#closing","text":"That's pretty much of it. Hope you enjoyed reading it. In case of any mistake, typos, etc. Please report the article. You can also give us reviews here","title":"Closing!"},{"location":"Luau-Learning/Tweening/","text":"Tweening This article will teach you about the concept of tweening, how tweening is useful in development and how to use the TweenService in Roblox. 1. What is \"tweening\"? Inbetweening - tweening for short - is basically an animated process to create an illusion or effect, usually smooth, in transition between two keyframes in an animation or presentation. Here's what the animation looks like in action: A comparison between tweening and no tweening, both have the same transition interval of 1 second: In this example, the size of both circles is being \"tweened\", both have the same transition interval of 1 second: As you can see, tweening did a good job in visualize the transition inbetween the 2 keyframes. 2. How useful is tweening? I don't know about you, but I like my animation smooth and appealing. Besides that, tweening can also help you: Create animations / presentation easier, considering that tweening can reduce the amount of keyframes Execute multiple animation on a single instance (e.g. color, size, ...) Create VFX (Visual Effect) Simply make the animations less snappy and more easy-looking for the audience Now that you have the basics and uses of tweening on hand, let's do some animation in Roblox! TweenService 1. What is TweenService? TweenService is a built-in API Service, allowing developers to script the tweening effect on instances such as BasePart (Part, MeshPart, ...) and GuiObject (TextLabel, ImageLabel, ...) through interpolation in properties. Basically, this service creates animation on an object by changing it's properties in a particular way. 2. List of types that can be tweened TweenService can only help animating properties of type in the following list: number boolean CFrame Rect Color3 UDim UDim2 Vector2 Vector2int16 Vector3 EnumItem This list is important to remember, any other properties of type outside of this list can NOT be animated by TweenService . What are some valid properties? For instances like Part: Position , CFrame , Size , Color , Transparency , ... For UI elements: Position , Size , Rotation , BackgroundColor3 , TextColor3 , BackgroundTransparency , ... How do I use the TweenService? 1. Determine the target to tween In this article, we are going to make a dance floor for our players. A little party area is fun for hanging out or show off your newly equipped emotes! I made this little 3x3 dance floor so it's easier to demonstrate. Each gray tiles is a Part instance. You can design it however you want! If you don't follow this example's structure, make sure: To make the code suit with your own structure To have the list of valid properties in mind And here's how the Explorer hierachy looks like ( View -> Explorer to open the Explorer window) * The black bars go into the \"Bars\" folder, which will be ignored later on. * The gray tiles go into the \"Tiles\" folder, which will be our tweening targets . * The \"Control\" script, which we will write the tweening code . 2. Determine what to tween Take a look at this simple but fancy dance floor we're going to make: As you can see, each floor tiles is smoothly changing it's color, creating a colorful atmosphere around our player. So, we will tween the tiles' Color properties with the TweenService . 3. Determine how the tween will be, using TweenInfo Now, take a closer look into the video. There's a pattern on how the tiles are tweening . To determine how they tween, we will use the TweenInfo datatype, as for tween ing info rmation. TweenInfo have only one constructor, TweenInfo.new() , along with six parameters : time: number - Duration of the tween, in seconds easingStyle: Enum.EasingStyle - The \"style\", or how the tween looks like easingDirection: Enum.EasingDirection - The direction for the EasingStyle to occur repeatCount: number - The amount of times the tween will repeat itself reverses: boolean - Whether or not reverse to the original state after the initial tween delayTime: number - The duration that elapses before the tween play, in seconds The order of the parameters are absolute You can NOT rearrange this order. Hence, wrong parameter order can result in an unwanted tween behaviour or even an error. You must also give the correct type (they're written after the colon) for each parameter. Repeat the tween indefintely To make the tween repeat itself forever, set the repeatCount value to -1 . Visual example of each EasingStyle and EasingDirection Roblox has made a video covering all 6 EasingStyle and 2 EasingDirection : The default values of TweenInfo.new() Assume you're lazy and you don't want to type out all 6 parameters, TweenInfo.new() will automatically fill the missing arguments with the follow values: time : 1 easingStyle : Enum.EasingStyle.Quad easingDirection : Enum.EasingDirection.Out repeatCount : 0 reverses : false delayTime : 0 I will cover them all in this example, so pay attention! Open the control script, type in the following code. The comments will help you understand what line contribute what to the tween animation: local tween_info = TweenInfo . new ( -- Remember: parenthesis () not brackets {} 1 , -- The color will change in 1 second Enum . EasingStyle . Linear , -- Tween at a constant speed Enum . EasingDirection . In , -- In or Out doesn't matter, as the tween is in constant speed - 1 , -- Automatically repeat the tween indefinitely, so we don't have to true , -- Reverse to the original color, for a little colorful effect 0 -- Make the tween play instantly ) You can adjust the values to your liking Make sure to give the correct type for each parameter. 4. Create a tween using TweenService:Create() To create a tween sequence, we will use the TweenService:Create() method. This method will return a Tween sequence for us to interact in the next section. TweenService:Create() has 3 parameters , the order is absolute: instance - The target instance to tween tweenInfo - The TweenInfo for the tween sequence propertyTable - The target properties to tween The propertyTable parameter propertyTable takes a dictionary table as an argument. The syntax is as the following: local target = { < property_name_1 > = < target_value_1 > , < property_name_2 > = < target_value_2 > , ..., < property_name_n > = < target_value_n > } Remember those gray tiles in the \"Tiles\" folder? That's our targets to tween. But, the instance parameter only takes 1 instance. So, we will have to create 9 tween sequences for our dance floor. We can use a for loop to simutaneously create one tween sequence for each tiles in the folder. Regarding the following code While this code is not the most efficient way to tween multiple instances, it is written for the sake of beginners. You can, later on, alter the code and the overall structure to your liking. -- Get the service with the GetService() method local TweenService = game : GetService ( \"TweenService\" ) -- Get the \"Tiles\" folder, which is holding our gray tiles local tiles = script . Parent . Tiles -- The TweenInfo we created earlier, I have collapsed into one line local tween_info = TweenInfo . new ( 1 , Enum . EasingStyle . Linear , Enum . EasingDirection . In , - 1 , true , 0 ) -- We will determine the target color for the tiles with a dictionary -- \"Color\" is one of the tile's properties. To see all the properties of a part, go to \"View\" -> \"Properties\" to toggle the \"Properties\" window local target_color = { Color = Color3 . fromRGB ( 100 , 57 , 64 ) -- This is red, you can change to whatever color you want } -- The following code require basic understandings of the for loop -- tiles:GetChildren() return an array containing all the tiles for i , tile in ipairs ( tiles : GetChildren ()) do -- Create a tween sequence local tween = TweenService : Create ( tile , -- The gray tile instance tween_info , -- The tween info target_color -- The target color ) end Now, we have successfully assign 9 tween sequences to 9 tiles. But we're not done yet . When you play test the game, you will see the dance floor is just sitting still and nothing happen. This is because we have just created the tween sequences, but we haven't actually play them yet. The following section will help you with that. 5. Play the tween using tween:Play() This method is self-explanatory. It will play the tween sequence the moment it is called. Note Keep in mind that this method is exclusive to the tween sequence (created by the TweenService:Create() method). This is NOT a method of the TweenService . We just need to add a single line of code to call this method and play the tween: local TweenService = game : GetService ( \"TweenService\" ) local tiles = script . Parent . Tiles local tween_info = TweenInfo . new ( 1 , Enum . EasingStyle . Linear , Enum . EasingDirection . In , - 1 , true , 0 ) local target_color = { Color = Color3 . fromRGB ( 100 , 57 , 64 ) } for i , tile in ipairs ( tiles : GetChildren ()) do local tween = TweenService : Create ( tile , tween_info , target_color ) tween : Play () -- Play the tween end Now we play test again: It's actually a bad timing GIF, so hopefully it will look better on your side! But more importantly, you have successfully know how to use the TweenService to make a simple tween animation! Exercise: Complete the dance floor at the beginning (open for solution) As you can see from the original video, there are 2 different tweening patterns. So let's do that: The tiles that create the cross shape will be named \"Tile1\", the other four, \"Tile2\". Initially, all 9 tiles are gray colored, so how does the video shows blue and red? The trick here is: - Instead of gray, the tiles are colored with their designated colors at the beginning: Tile1 is blue, Tile2 is red. - Set the color target: Tile1 will be tweened red, while Tile2 will be tweened blue. - Distinguish the tiles using conditional statements . Since we set the tween reverses property to true , it will reverse back to it's original color. Instead of gray, it will be red and blue. Here's how the code looks like: local TweenService = game : GetService ( \"TweenService\" ) local tiles = script . Parent . Tiles local tween_info = TweenInfo . new ( 1 , Enum . EasingStyle . Linear , Enum . EasingDirection . In , - 1 , true , 0 ) local color1 = { Color = Color3 . fromRGB ( 255 , 89 , 89 ) -- Red, for Tile2 } local color2 = { Color = Color3 . fromRGB ( 4 , 175 , 236 ) -- Blue, for Tile1 } for i , tile in ipairs ( tiles : GetChildren ()) do local tween -- A placeholder for the tween -- Filter the tiles if tile . Name == \"Tile1\" then tween = TweenService : Create ( tile , tween_info , color1 ) else tween = TweenService : Create ( tile , tween_info , color2 ) end tween : Play () -- Play the tween end 6. tween:Cancel() , tween:Pause() and tween:Resume() These methods is self-explanatory in name. This section will help you distinguish the differences between tween:Cancel() and tween:Pause() . Both methods will halt the playing tween at the current interpolation at the moment they're called. This means that the target instance will not be reset to it's original state before tweening is initiated. A quick visual example, both circles have the tween duration of 1 second. tween:Cancel() is called after 0.5 second. The same effect is applied when tween:Pause() is used. Here are the differences between the 2 methods: * tween:Pause() can be resumed by either tween:Play() or tween:Resume() . Upon resuming, the tween will continue at the moment it was halted . * tween:Cancel can be continued by the tween:Play() method only . Upon continuing, all current tweening information will be reset . For example: it will take full duration of the tween to finish the animation. 7. The tween.Completed event tween.Completed is an Event ( RbxScriptSignal ) that fires after the tweening process is completed or cancelled by the Cancel method. tween.Completed pass 1 parameter, the playbackState . You can see all types of playbackState in this page . tween . Completed : Connect ( function ( playbackState ) print ( playbackState ) end ) !!! info \"playbackState\" is likely to be one of 2 values: - Enum.PlaybackState.Completed : If the tween completed successfully. - Enum.PlaybackState.Cancelled : If the tween is cancelled by the Cancel method before completion. Additional sources Official Roblox TweenService documentation Official Roblox Tween sequence documentation Detailed Roblox documentation regarding Easing Styles and Directions Roblox guide on User Interface Tweening More about the concept of Tweening (wikipedia) That's about it Use TweenService to further improve in-game experience as you please. Good luck!","title":"Tweening"},{"location":"Luau-Learning/Tweening/#tweening","text":"This article will teach you about the concept of tweening, how tweening is useful in development and how to use the TweenService in Roblox.","title":"Tweening"},{"location":"Luau-Learning/Tweening/#1-what-is-tweening","text":"Inbetweening - tweening for short - is basically an animated process to create an illusion or effect, usually smooth, in transition between two keyframes in an animation or presentation. Here's what the animation looks like in action: A comparison between tweening and no tweening, both have the same transition interval of 1 second: In this example, the size of both circles is being \"tweened\", both have the same transition interval of 1 second: As you can see, tweening did a good job in visualize the transition inbetween the 2 keyframes.","title":"1. What is \"tweening\"?"},{"location":"Luau-Learning/Tweening/#2-how-useful-is-tweening","text":"I don't know about you, but I like my animation smooth and appealing. Besides that, tweening can also help you: Create animations / presentation easier, considering that tweening can reduce the amount of keyframes Execute multiple animation on a single instance (e.g. color, size, ...) Create VFX (Visual Effect) Simply make the animations less snappy and more easy-looking for the audience Now that you have the basics and uses of tweening on hand, let's do some animation in Roblox!","title":"2. How useful is tweening?"},{"location":"Luau-Learning/Tweening/#tweenservice","text":"","title":"TweenService"},{"location":"Luau-Learning/Tweening/#1-what-is-tweenservice","text":"TweenService is a built-in API Service, allowing developers to script the tweening effect on instances such as BasePart (Part, MeshPart, ...) and GuiObject (TextLabel, ImageLabel, ...) through interpolation in properties. Basically, this service creates animation on an object by changing it's properties in a particular way.","title":"1. What is TweenService?"},{"location":"Luau-Learning/Tweening/#2-list-of-types-that-can-be-tweened","text":"TweenService can only help animating properties of type in the following list: number boolean CFrame Rect Color3 UDim UDim2 Vector2 Vector2int16 Vector3 EnumItem This list is important to remember, any other properties of type outside of this list can NOT be animated by TweenService . What are some valid properties? For instances like Part: Position , CFrame , Size , Color , Transparency , ... For UI elements: Position , Size , Rotation , BackgroundColor3 , TextColor3 , BackgroundTransparency , ...","title":"2. List of types that can be tweened"},{"location":"Luau-Learning/Tweening/#how-do-i-use-the-tweenservice","text":"","title":"How do I use the TweenService?"},{"location":"Luau-Learning/Tweening/#1-determine-the-target-to-tween","text":"In this article, we are going to make a dance floor for our players. A little party area is fun for hanging out or show off your newly equipped emotes! I made this little 3x3 dance floor so it's easier to demonstrate. Each gray tiles is a Part instance. You can design it however you want! If you don't follow this example's structure, make sure: To make the code suit with your own structure To have the list of valid properties in mind And here's how the Explorer hierachy looks like ( View -> Explorer to open the Explorer window) * The black bars go into the \"Bars\" folder, which will be ignored later on. * The gray tiles go into the \"Tiles\" folder, which will be our tweening targets . * The \"Control\" script, which we will write the tweening code .","title":"1. Determine the target to tween"},{"location":"Luau-Learning/Tweening/#2-determine-what-to-tween","text":"Take a look at this simple but fancy dance floor we're going to make: As you can see, each floor tiles is smoothly changing it's color, creating a colorful atmosphere around our player. So, we will tween the tiles' Color properties with the TweenService .","title":"2. Determine what to tween"},{"location":"Luau-Learning/Tweening/#3-determine-how-the-tween-will-be-using-tweeninfo","text":"Now, take a closer look into the video. There's a pattern on how the tiles are tweening . To determine how they tween, we will use the TweenInfo datatype, as for tween ing info rmation. TweenInfo have only one constructor, TweenInfo.new() , along with six parameters : time: number - Duration of the tween, in seconds easingStyle: Enum.EasingStyle - The \"style\", or how the tween looks like easingDirection: Enum.EasingDirection - The direction for the EasingStyle to occur repeatCount: number - The amount of times the tween will repeat itself reverses: boolean - Whether or not reverse to the original state after the initial tween delayTime: number - The duration that elapses before the tween play, in seconds The order of the parameters are absolute You can NOT rearrange this order. Hence, wrong parameter order can result in an unwanted tween behaviour or even an error. You must also give the correct type (they're written after the colon) for each parameter. Repeat the tween indefintely To make the tween repeat itself forever, set the repeatCount value to -1 . Visual example of each EasingStyle and EasingDirection Roblox has made a video covering all 6 EasingStyle and 2 EasingDirection : The default values of TweenInfo.new() Assume you're lazy and you don't want to type out all 6 parameters, TweenInfo.new() will automatically fill the missing arguments with the follow values: time : 1 easingStyle : Enum.EasingStyle.Quad easingDirection : Enum.EasingDirection.Out repeatCount : 0 reverses : false delayTime : 0 I will cover them all in this example, so pay attention! Open the control script, type in the following code. The comments will help you understand what line contribute what to the tween animation: local tween_info = TweenInfo . new ( -- Remember: parenthesis () not brackets {} 1 , -- The color will change in 1 second Enum . EasingStyle . Linear , -- Tween at a constant speed Enum . EasingDirection . In , -- In or Out doesn't matter, as the tween is in constant speed - 1 , -- Automatically repeat the tween indefinitely, so we don't have to true , -- Reverse to the original color, for a little colorful effect 0 -- Make the tween play instantly ) You can adjust the values to your liking Make sure to give the correct type for each parameter.","title":"3. Determine how the tween will be, using TweenInfo"},{"location":"Luau-Learning/Tweening/#4-create-a-tween-using-tweenservicecreate","text":"To create a tween sequence, we will use the TweenService:Create() method. This method will return a Tween sequence for us to interact in the next section. TweenService:Create() has 3 parameters , the order is absolute: instance - The target instance to tween tweenInfo - The TweenInfo for the tween sequence propertyTable - The target properties to tween The propertyTable parameter propertyTable takes a dictionary table as an argument. The syntax is as the following: local target = { < property_name_1 > = < target_value_1 > , < property_name_2 > = < target_value_2 > , ..., < property_name_n > = < target_value_n > } Remember those gray tiles in the \"Tiles\" folder? That's our targets to tween. But, the instance parameter only takes 1 instance. So, we will have to create 9 tween sequences for our dance floor. We can use a for loop to simutaneously create one tween sequence for each tiles in the folder. Regarding the following code While this code is not the most efficient way to tween multiple instances, it is written for the sake of beginners. You can, later on, alter the code and the overall structure to your liking. -- Get the service with the GetService() method local TweenService = game : GetService ( \"TweenService\" ) -- Get the \"Tiles\" folder, which is holding our gray tiles local tiles = script . Parent . Tiles -- The TweenInfo we created earlier, I have collapsed into one line local tween_info = TweenInfo . new ( 1 , Enum . EasingStyle . Linear , Enum . EasingDirection . In , - 1 , true , 0 ) -- We will determine the target color for the tiles with a dictionary -- \"Color\" is one of the tile's properties. To see all the properties of a part, go to \"View\" -> \"Properties\" to toggle the \"Properties\" window local target_color = { Color = Color3 . fromRGB ( 100 , 57 , 64 ) -- This is red, you can change to whatever color you want } -- The following code require basic understandings of the for loop -- tiles:GetChildren() return an array containing all the tiles for i , tile in ipairs ( tiles : GetChildren ()) do -- Create a tween sequence local tween = TweenService : Create ( tile , -- The gray tile instance tween_info , -- The tween info target_color -- The target color ) end Now, we have successfully assign 9 tween sequences to 9 tiles. But we're not done yet . When you play test the game, you will see the dance floor is just sitting still and nothing happen. This is because we have just created the tween sequences, but we haven't actually play them yet. The following section will help you with that.","title":"4. Create a tween using TweenService:Create()"},{"location":"Luau-Learning/Tweening/#5-play-the-tween-using-tweenplay","text":"This method is self-explanatory. It will play the tween sequence the moment it is called. Note Keep in mind that this method is exclusive to the tween sequence (created by the TweenService:Create() method). This is NOT a method of the TweenService . We just need to add a single line of code to call this method and play the tween: local TweenService = game : GetService ( \"TweenService\" ) local tiles = script . Parent . Tiles local tween_info = TweenInfo . new ( 1 , Enum . EasingStyle . Linear , Enum . EasingDirection . In , - 1 , true , 0 ) local target_color = { Color = Color3 . fromRGB ( 100 , 57 , 64 ) } for i , tile in ipairs ( tiles : GetChildren ()) do local tween = TweenService : Create ( tile , tween_info , target_color ) tween : Play () -- Play the tween end Now we play test again: It's actually a bad timing GIF, so hopefully it will look better on your side! But more importantly, you have successfully know how to use the TweenService to make a simple tween animation! Exercise: Complete the dance floor at the beginning (open for solution) As you can see from the original video, there are 2 different tweening patterns. So let's do that: The tiles that create the cross shape will be named \"Tile1\", the other four, \"Tile2\". Initially, all 9 tiles are gray colored, so how does the video shows blue and red? The trick here is: - Instead of gray, the tiles are colored with their designated colors at the beginning: Tile1 is blue, Tile2 is red. - Set the color target: Tile1 will be tweened red, while Tile2 will be tweened blue. - Distinguish the tiles using conditional statements . Since we set the tween reverses property to true , it will reverse back to it's original color. Instead of gray, it will be red and blue. Here's how the code looks like: local TweenService = game : GetService ( \"TweenService\" ) local tiles = script . Parent . Tiles local tween_info = TweenInfo . new ( 1 , Enum . EasingStyle . Linear , Enum . EasingDirection . In , - 1 , true , 0 ) local color1 = { Color = Color3 . fromRGB ( 255 , 89 , 89 ) -- Red, for Tile2 } local color2 = { Color = Color3 . fromRGB ( 4 , 175 , 236 ) -- Blue, for Tile1 } for i , tile in ipairs ( tiles : GetChildren ()) do local tween -- A placeholder for the tween -- Filter the tiles if tile . Name == \"Tile1\" then tween = TweenService : Create ( tile , tween_info , color1 ) else tween = TweenService : Create ( tile , tween_info , color2 ) end tween : Play () -- Play the tween end","title":"5. Play the tween using tween:Play()"},{"location":"Luau-Learning/Tweening/#6-tweencancel-tweenpause-and-tweenresume","text":"These methods is self-explanatory in name. This section will help you distinguish the differences between tween:Cancel() and tween:Pause() . Both methods will halt the playing tween at the current interpolation at the moment they're called. This means that the target instance will not be reset to it's original state before tweening is initiated. A quick visual example, both circles have the tween duration of 1 second. tween:Cancel() is called after 0.5 second. The same effect is applied when tween:Pause() is used. Here are the differences between the 2 methods: * tween:Pause() can be resumed by either tween:Play() or tween:Resume() . Upon resuming, the tween will continue at the moment it was halted . * tween:Cancel can be continued by the tween:Play() method only . Upon continuing, all current tweening information will be reset . For example: it will take full duration of the tween to finish the animation.","title":"6. tween:Cancel(), tween:Pause() and tween:Resume()"},{"location":"Luau-Learning/Tweening/#7-the-tweencompleted-event","text":"tween.Completed is an Event ( RbxScriptSignal ) that fires after the tweening process is completed or cancelled by the Cancel method. tween.Completed pass 1 parameter, the playbackState . You can see all types of playbackState in this page . tween . Completed : Connect ( function ( playbackState ) print ( playbackState ) end ) !!! info \"playbackState\" is likely to be one of 2 values: - Enum.PlaybackState.Completed : If the tween completed successfully. - Enum.PlaybackState.Cancelled : If the tween is cancelled by the Cancel method before completion.","title":"7. The tween.Completed event"},{"location":"Luau-Learning/Tweening/#additional-sources","text":"Official Roblox TweenService documentation Official Roblox Tween sequence documentation Detailed Roblox documentation regarding Easing Styles and Directions Roblox guide on User Interface Tweening More about the concept of Tweening (wikipedia)","title":"Additional sources"},{"location":"Luau-Learning/Tweening/#thats-about-it","text":"Use TweenService to further improve in-game experience as you please. Good luck!","title":"That's about it"},{"location":"Luau-Learning/Variables/","text":"Variables A variable is basically a name that can hold values. These values can be numbers , strings , tables and other Roblox data types . Naming Variables Variable name can contain English letters, numerical digits and underscores. A variable name can start with letters and underscores but can not start with digits. Correct Names Eden Teerach_Noob Rose22 _Willie lua is a case-sensitive language. This means, Eden and eden will be treated as two different variables. Keywords such as for , break , true , local , etc can't be utilised as variable names. Wrong Names if 21st_century Assigning Values The operator = is used for assignment of values. Consider the following example Code Output sloth = \"a lazy animal\" print ( sloth ) a lazy animal A declared variable can be changed anytime by assigning another value to it. Code Output Deden = 4 print ( Deden ) Deden = 17 print ( Deden ) 4 17 Multiple assignment Lua also enables its users to declare multiple variables at once. It can be done by separating variable names and their values by , . Salzu , Paper , Eden = \"Fox\" , \"China\" , \"Rose\" In the above example variables will be assigned values in serial order. Scopes In lua, a variable can be declared in any of the two scopes local and global . Global Variables Variables declared in global scope is accessible in all the scopes of a script. Every variable by default is a global variable unless declared with the keyword local . Code Output do -- first scope x = 9 print ( x ) end do -- second scope print ( x ) end 9 9 The variable declared in first scope is accessible in second scope. Warning Because global variables and functions must be accessed by a hash lookup, they can be expensive to use in terms of performance. In fact, a global variable accessed in a time-critical loop can perform 10% slower (or worse) than a local variable in the same loop. As noted earlier, global variables and functions are only accessible within the associated script, not between multiple scripts. Local Variables Local variables are declared with the keyword local and are only accessible in the scope in which they are defined. Code Output do -- first scope local x = 9 print ( x ) end do -- second scope print ( x ) end 9 nil The local variable declared in first scope is accessible only in first scope and is nil for second scope. Closing! Thanks for reading! I hope you enjoyed. We aren't perfect. We make mistakes, typos, etc. so if you found a mistake while reading this article, or any article for that matter, feel free to report it , and perhaps you can review us too! Any feedback is appreciated.","title":"Variables"},{"location":"Luau-Learning/Variables/#variables","text":"A variable is basically a name that can hold values. These values can be numbers , strings , tables and other Roblox data types .","title":"Variables"},{"location":"Luau-Learning/Variables/#naming-variables","text":"Variable name can contain English letters, numerical digits and underscores. A variable name can start with letters and underscores but can not start with digits. Correct Names Eden Teerach_Noob Rose22 _Willie lua is a case-sensitive language. This means, Eden and eden will be treated as two different variables. Keywords such as for , break , true , local , etc can't be utilised as variable names. Wrong Names if 21st_century","title":"Naming Variables"},{"location":"Luau-Learning/Variables/#assigning-values","text":"The operator = is used for assignment of values. Consider the following example Code Output sloth = \"a lazy animal\" print ( sloth ) a lazy animal A declared variable can be changed anytime by assigning another value to it. Code Output Deden = 4 print ( Deden ) Deden = 17 print ( Deden ) 4 17","title":"Assigning Values"},{"location":"Luau-Learning/Variables/#multiple-assignment","text":"Lua also enables its users to declare multiple variables at once. It can be done by separating variable names and their values by , . Salzu , Paper , Eden = \"Fox\" , \"China\" , \"Rose\" In the above example variables will be assigned values in serial order.","title":"Multiple assignment"},{"location":"Luau-Learning/Variables/#scopes","text":"In lua, a variable can be declared in any of the two scopes local and global .","title":"Scopes"},{"location":"Luau-Learning/Variables/#global-variables","text":"Variables declared in global scope is accessible in all the scopes of a script. Every variable by default is a global variable unless declared with the keyword local . Code Output do -- first scope x = 9 print ( x ) end do -- second scope print ( x ) end 9 9 The variable declared in first scope is accessible in second scope. Warning Because global variables and functions must be accessed by a hash lookup, they can be expensive to use in terms of performance. In fact, a global variable accessed in a time-critical loop can perform 10% slower (or worse) than a local variable in the same loop. As noted earlier, global variables and functions are only accessible within the associated script, not between multiple scripts.","title":"Global Variables"},{"location":"Luau-Learning/Variables/#local-variables","text":"Local variables are declared with the keyword local and are only accessible in the scope in which they are defined. Code Output do -- first scope local x = 9 print ( x ) end do -- second scope print ( x ) end 9 nil The local variable declared in first scope is accessible only in first scope and is nil for second scope.","title":"Local Variables"},{"location":"Luau-Learning/Variables/#closing","text":"Thanks for reading! I hope you enjoyed. We aren't perfect. We make mistakes, typos, etc. so if you found a mistake while reading this article, or any article for that matter, feel free to report it , and perhaps you can review us too! Any feedback is appreciated.","title":"Closing!"},{"location":"Luau-Learning/Vector3/","text":"Vector Before learning Vector3 you need to know what is a \"Vector\". Vector is a physical quantity that has a magnitude and a direction. A vector is graphically represented by an arrow drawn parallel to the direction of the vector, The length of the arrow represents the magnitude of the vector. 2D Vector In 2 dimensions, where you have two coordinates/axis X-Axis and Y-Axis . They are perpendicular to each other. A vector is drawn from the origin (0,0) to the (10,10) coordinate point of the plane. These coordinate points represent the magnitude of the vector on the X and Y axis and are written as (X, Y) . 3D Vector In three-dimensional space, There are three axes X-Axis , Y-Axis , and Z-Axis . A 3D vector is the same as 2D but with an extra dimension. The rest of our topic will be based on a three-dimensional vector. Similar to a 2D vector, coordinates of a vector in 3 dimensions are written as (10,10,10) . These coordinate points represent the magnitude of the vector on the X, Y, and Z axis and are written as (X, Y, Z) . Confused about how we calculated the magnitude? The length of the vector on each axis is represented by three lines. Each of them is parallel to one of the lines of the axis. The line parallel to the x-axis represents its magnitude on the x-axis, the same for the y and z-axis. Vector in Roblox In Roblox, a Vector3 is a vector in the three-dimensional space. It is created by Vector3.new(x,y,z) . Roblox engine uses Vector3 in multiple cases, such as positioning base parts, size of base parts, setting directions of linear velocities, etc. In every case the origin of the vector is different. We will talk about them later. For now, we will go through some common properties of Vector3. Magnitude of a Vector. For your easiness, Roblox allows you to get the magnitude of a vector by just Vector3.Magnitude . As mentioned earlier, magnitude is the length of the vector. If v is a vector and its coordinates are (10,13,10) then its magnitude is given by |V| = \u221a(x^2 + y^2 + z^2) |V| = \u221a(10^2 + 13^2 + 10^2) |V| = \u221a(100 + 169 + 100) |V| = \u221a(369) |V| = 19.209 Now, in the studio, add the following code in a script and run. Code Output local vector = Vector3 . new ( 10 , 13 , 10 ) print ( vector . Magnitude ) 19.209 It is the length of a vector given in studs. Unit Vector A unit vector is a vector with a magnitude 1 . It can be obtained by dividing a vector by its magnitude. If u is a vector of magnitude (10,13,10) then its unit vector \u00fb can be obtained by \u00fb = u / |u| We will first calculate the magnitude and divide it by every component of the vector. |u| = \u221a(x^2 + y^2 + z^2) |u| = \u221a(10^2 + 13^2 + 10^2) |u| = \u221a(100 + 169 + 100) |u| = \u221a(369) |u| = 19.209 Let x2, y2, and z2 be the x,y, and z components of \u00fb . Dividing x,y, and z components of u by |u| x2 = x / |u| = 10 / 19.209 = 0.5205 y2 = y / |u| = 13 / 19.209 = 0.6767 z2 = z / |u| = 10 / 19.209 = 0.5205 We have obtained by x,y, and z components of the unit vector ( \u00fb ). Now the coordinates of \u00fb is (0.5205,0.6767,0.5205). If it is a unit vector then its magnitude must be 1. Let's prove that |\u00fb| = \u221a(x^2 + y^2 + z^2) |\u00fb| = \u221a(0.5205^2 + 0.6767^2 + 0.5205^2) |\u00fb| = \u221a(0.2709 + 0.4579 + 0.2709) |\u00fb| = \u221a(1) -- nearly 1 |\u00fb| = 1 In the studio, you can easily get the unit vector of a vector by Vector3.Unit . Code Output local vector = Vector3.new(10,13,10) print(vector.Unit) 0.5205791592597961, 0.6767529249191284, 0.5205791592597961 If you look carefully, you can see it is the same as we calculated. Unit vectors are mainly used for specifying directions. The Direction of a vector and its unit vector always remain the same. Did you just waste my time when you could get it that easily? No, I could explain you more easily by just saying use .Unit and .Magnitude but it will never clear your concepts of magnitude and unit. The purpose of deriving was to explain what exactly it is. Normal Vector A vector perpendicular to a surface is called a normal vector. In Roblox, you can find a normal vector in RaycastResult.Normal . This vector is normal to the intersected face. There are many other use cases that you will find when computing vector maths Closing! I hope it helped in developing a better understanding of vectors and Vector3. Feel free to report this article if there is any mistake. There is a few stuff left regarding vectors and we will discuss them later. For now, bai!","title":"Vector3"},{"location":"Luau-Learning/Vector3/#vector","text":"Before learning Vector3 you need to know what is a \"Vector\". Vector is a physical quantity that has a magnitude and a direction. A vector is graphically represented by an arrow drawn parallel to the direction of the vector, The length of the arrow represents the magnitude of the vector.","title":"Vector"},{"location":"Luau-Learning/Vector3/#2d-vector","text":"In 2 dimensions, where you have two coordinates/axis X-Axis and Y-Axis . They are perpendicular to each other. A vector is drawn from the origin (0,0) to the (10,10) coordinate point of the plane. These coordinate points represent the magnitude of the vector on the X and Y axis and are written as (X, Y) .","title":"2D Vector"},{"location":"Luau-Learning/Vector3/#3d-vector","text":"In three-dimensional space, There are three axes X-Axis , Y-Axis , and Z-Axis . A 3D vector is the same as 2D but with an extra dimension. The rest of our topic will be based on a three-dimensional vector. Similar to a 2D vector, coordinates of a vector in 3 dimensions are written as (10,10,10) . These coordinate points represent the magnitude of the vector on the X, Y, and Z axis and are written as (X, Y, Z) . Confused about how we calculated the magnitude? The length of the vector on each axis is represented by three lines. Each of them is parallel to one of the lines of the axis. The line parallel to the x-axis represents its magnitude on the x-axis, the same for the y and z-axis.","title":"3D Vector"},{"location":"Luau-Learning/Vector3/#vector-in-roblox","text":"In Roblox, a Vector3 is a vector in the three-dimensional space. It is created by Vector3.new(x,y,z) . Roblox engine uses Vector3 in multiple cases, such as positioning base parts, size of base parts, setting directions of linear velocities, etc. In every case the origin of the vector is different. We will talk about them later. For now, we will go through some common properties of Vector3.","title":"Vector in Roblox"},{"location":"Luau-Learning/Vector3/#magnitude-of-a-vector","text":"For your easiness, Roblox allows you to get the magnitude of a vector by just Vector3.Magnitude . As mentioned earlier, magnitude is the length of the vector. If v is a vector and its coordinates are (10,13,10) then its magnitude is given by |V| = \u221a(x^2 + y^2 + z^2) |V| = \u221a(10^2 + 13^2 + 10^2) |V| = \u221a(100 + 169 + 100) |V| = \u221a(369) |V| = 19.209 Now, in the studio, add the following code in a script and run. Code Output local vector = Vector3 . new ( 10 , 13 , 10 ) print ( vector . Magnitude ) 19.209 It is the length of a vector given in studs.","title":"Magnitude of a Vector."},{"location":"Luau-Learning/Vector3/#unit-vector","text":"A unit vector is a vector with a magnitude 1 . It can be obtained by dividing a vector by its magnitude. If u is a vector of magnitude (10,13,10) then its unit vector \u00fb can be obtained by \u00fb = u / |u| We will first calculate the magnitude and divide it by every component of the vector. |u| = \u221a(x^2 + y^2 + z^2) |u| = \u221a(10^2 + 13^2 + 10^2) |u| = \u221a(100 + 169 + 100) |u| = \u221a(369) |u| = 19.209 Let x2, y2, and z2 be the x,y, and z components of \u00fb . Dividing x,y, and z components of u by |u| x2 = x / |u| = 10 / 19.209 = 0.5205 y2 = y / |u| = 13 / 19.209 = 0.6767 z2 = z / |u| = 10 / 19.209 = 0.5205 We have obtained by x,y, and z components of the unit vector ( \u00fb ). Now the coordinates of \u00fb is (0.5205,0.6767,0.5205). If it is a unit vector then its magnitude must be 1. Let's prove that |\u00fb| = \u221a(x^2 + y^2 + z^2) |\u00fb| = \u221a(0.5205^2 + 0.6767^2 + 0.5205^2) |\u00fb| = \u221a(0.2709 + 0.4579 + 0.2709) |\u00fb| = \u221a(1) -- nearly 1 |\u00fb| = 1 In the studio, you can easily get the unit vector of a vector by Vector3.Unit . Code Output local vector = Vector3.new(10,13,10) print(vector.Unit) 0.5205791592597961, 0.6767529249191284, 0.5205791592597961 If you look carefully, you can see it is the same as we calculated. Unit vectors are mainly used for specifying directions. The Direction of a vector and its unit vector always remain the same. Did you just waste my time when you could get it that easily? No, I could explain you more easily by just saying use .Unit and .Magnitude but it will never clear your concepts of magnitude and unit. The purpose of deriving was to explain what exactly it is.","title":"Unit Vector"},{"location":"Luau-Learning/Vector3/#normal-vector","text":"A vector perpendicular to a surface is called a normal vector. In Roblox, you can find a normal vector in RaycastResult.Normal . This vector is normal to the intersected face. There are many other use cases that you will find when computing vector maths","title":"Normal Vector"},{"location":"Luau-Learning/Vector3/#closing","text":"I hope it helped in developing a better understanding of vectors and Vector3. Feel free to report this article if there is any mistake. There is a few stuff left regarding vectors and we will discuss them later. For now, bai!","title":"Closing!"},{"location":"Luau-Learning/Vector3_Part_2/","text":"Vector3 pt. 2 Previously we talked about Vectors Magnitude of vectors Unit vectors Normal vectors Now we will move further and talk about vector manipulation. Addition of Vectors. The addition of vectors means putting two or more vectors together. We will add two or more vectors to obtain a new vector equal to the sum of vectors. There are two laws for the addition of vectors Triangle law (Head to tail law) Parallelogram law In this guide, we will only explain Triangle law (sorry but once you understand triangle law you will understand the basic graphical addition of vectors). Addition of Vectors with Triangle Law According to this law, two vectors can be added by placing them together in such a way that the head of the one joins the tail of the other. Thus, the resultant vector can be obtained by joining the tail of the first vector with the head of the second vector. This can be explained in the following steps: Consider two vectors U and V. Place the vector V in such a manner that its tail connects to the head of U . A resultant vector R is drawn in such a way that it connects the tail of U to the head of V . Thus, when the two vectors U and V are added using the triangle law, we can see that a triangle is formed by the two original vectors U and V , and the sum vector R . Multiplication of Vectors Multiplication of vectors is of two types Multiplication of a vector with a scalar. Multiplication of a vector with another vector. Multiplication of a vector with a scalar For multiplying a vector by a scaler, multiply each component of the vector with the scaler. If V is a vector of coordinates (8,5,9) and is multiplied by 10 , their product U is given by U = V * 10 U = (8, 5, 9) * 10 U = (80, 50, 90) Closing! That's pretty much of it. Hope you enjoyed reading it. In case of any mistake, typos, etc. Please report the article. You can also give us reviews here","title":"Vector3 pt. 2"},{"location":"Luau-Learning/Vector3_Part_2/#vector3-pt-2","text":"Previously we talked about Vectors Magnitude of vectors Unit vectors Normal vectors Now we will move further and talk about vector manipulation.","title":"Vector3 pt. 2"},{"location":"Luau-Learning/Vector3_Part_2/#addition-of-vectors","text":"The addition of vectors means putting two or more vectors together. We will add two or more vectors to obtain a new vector equal to the sum of vectors. There are two laws for the addition of vectors Triangle law (Head to tail law) Parallelogram law In this guide, we will only explain Triangle law (sorry but once you understand triangle law you will understand the basic graphical addition of vectors).","title":"Addition of Vectors."},{"location":"Luau-Learning/Vector3_Part_2/#addition-of-vectors-with-triangle-law","text":"According to this law, two vectors can be added by placing them together in such a way that the head of the one joins the tail of the other. Thus, the resultant vector can be obtained by joining the tail of the first vector with the head of the second vector. This can be explained in the following steps: Consider two vectors U and V. Place the vector V in such a manner that its tail connects to the head of U . A resultant vector R is drawn in such a way that it connects the tail of U to the head of V . Thus, when the two vectors U and V are added using the triangle law, we can see that a triangle is formed by the two original vectors U and V , and the sum vector R .","title":"Addition of Vectors with Triangle Law"},{"location":"Luau-Learning/Vector3_Part_2/#multiplication-of-vectors","text":"Multiplication of vectors is of two types Multiplication of a vector with a scalar. Multiplication of a vector with another vector.","title":"Multiplication of Vectors"},{"location":"Luau-Learning/Vector3_Part_2/#multiplication-of-a-vector-with-a-scalar","text":"For multiplying a vector by a scaler, multiply each component of the vector with the scaler. If V is a vector of coordinates (8,5,9) and is multiplied by 10 , their product U is given by U = V * 10 U = (8, 5, 9) * 10 U = (80, 50, 90)","title":"Multiplication of a vector with a scalar"},{"location":"Luau-Learning/Vector3_Part_2/#closing","text":"That's pretty much of it. Hope you enjoyed reading it. In case of any mistake, typos, etc. Please report the article. You can also give us reviews here","title":"Closing!"},{"location":"Luau-Learning/basic_loops/","text":"Loops in Lua Sooner or later while scripting, you will have to repeat instructions for your game to run - you do not want to have to constantly copy the instruction you want to keep running. This is where loops come in. Loops allow you to repeat a set of instructions to your game with none of the copy-paste nightmare. It also keeps your code organized and clean. Types of loops In Lua, there are multiple types of loops that you may use. They fill different niches, and you may have to use them for different occasions. while wait ( 1 ) do print ( \"deden\" ) end -- 'while' loop. for deden = 0 , 20 do print ( \"deden\" ) end -- 'for' loop. repeat deden = deden + 1 until deden < 20 -- 'repeat' loop. While Loops while loops first check the condition given. If the condition is true, it runs its code. This will repeat for as long as the condition remains true. Notice how the example below stops working when i is 5. Code Output local i = 0 while i < 5 do print ( i ) i = i + 1 end 1 2 3 4 while loops run for as long as the condition is true; if your condition remains true without changing and without a wait() , your while loop runs forever and will cause your game to hang. This is known as an infinite loop - avoid this at all costs. For Loops Given a number known as the counter, for loops repeat for as long as the counter does not hit the given maximum. Code Output for i = 1 , 5 do print ( i ) end 1 2 3 4 5 You may have noticed that for loops look very similarly to while loops. Consider that the for loop example runs similarly to the while loop example. For loop increments Notice how we used only 2 numbers in the statement for i = 1, 5 do . When you provide 2 numbers, the for loop in question will assume you are attempting to count up by increments of 1 (1, 2, 3, 4, 5) . You can override this behavior by providing a 3rd number, otherwise known as the increment. When you do so, your loop will instead start counting up in that increment. Code Output for i = 1 , 5 , 2 do print ( i ) end 1 3 5 In the example below, we have provided 2 as the increment. This tells the for loop to start counting up by 2 instead of the default 1. You can even apply this to have your for loop count DOWNWARDS. Code Output for i = 5 , 1 , - 1 do print ( i ) end 5 4 3 2 1 Warning An increment of 0 results in an infinite loop as the for loop never reaches the end value! Repeat loops repeat loops run the code, and then checks if the until condition is true. If it is NOT true, the loop repeats until the condition is true. This behaves very similarly to a while loop. However, a while loop checks its condition first. A repeat loop runs the code first, before checking its condition. A good way of phrasing this will be like so: \"while this is true, do this\" / \"check first, then do\" \"repeat doing this until this is true\" / \"do first, then check\" Code Output local i = 0 repeat i = i + 1 print ( i ) until i > 5 1 2 3 4 5 6 Notice the inequality sign (>) in the until statement. This can be interpreted as \"add 1 to i, then check if i is above 5. If yes, don't repeat anymore. Else, repeat.\" Code Output local i = 0 while i < 5 do i = i + 1 print ( i ) end 1 2 3 4 5 Notice the inequality sign (<) in the while statement, which is different from that in the repeat loop above. This can be interpreted as \"check if i is above 5. If yes, repeat. Else, skip and do not loop anymore.\" This is also why the while loop doesn't print 6, while the repeat loop does. Closing Loops are very powerful constructs that let you repeatedly run a set of instructions with minimal copy and paste. This makes your code easy to read and edit and also gives you more control over it. Where applicable, use the appropriate ones as much as possible!","title":"Basics about Loops"},{"location":"Luau-Learning/basic_loops/#loops-in-lua","text":"Sooner or later while scripting, you will have to repeat instructions for your game to run - you do not want to have to constantly copy the instruction you want to keep running. This is where loops come in. Loops allow you to repeat a set of instructions to your game with none of the copy-paste nightmare. It also keeps your code organized and clean.","title":"Loops in Lua"},{"location":"Luau-Learning/basic_loops/#types-of-loops","text":"In Lua, there are multiple types of loops that you may use. They fill different niches, and you may have to use them for different occasions. while wait ( 1 ) do print ( \"deden\" ) end -- 'while' loop. for deden = 0 , 20 do print ( \"deden\" ) end -- 'for' loop. repeat deden = deden + 1 until deden < 20 -- 'repeat' loop.","title":"Types of loops"},{"location":"Luau-Learning/basic_loops/#while-loops","text":"while loops first check the condition given. If the condition is true, it runs its code. This will repeat for as long as the condition remains true. Notice how the example below stops working when i is 5. Code Output local i = 0 while i < 5 do print ( i ) i = i + 1 end 1 2 3 4 while loops run for as long as the condition is true; if your condition remains true without changing and without a wait() , your while loop runs forever and will cause your game to hang. This is known as an infinite loop - avoid this at all costs.","title":"While Loops"},{"location":"Luau-Learning/basic_loops/#for-loops","text":"Given a number known as the counter, for loops repeat for as long as the counter does not hit the given maximum. Code Output for i = 1 , 5 do print ( i ) end 1 2 3 4 5 You may have noticed that for loops look very similarly to while loops. Consider that the for loop example runs similarly to the while loop example.","title":"For Loops"},{"location":"Luau-Learning/basic_loops/#for-loop-increments","text":"Notice how we used only 2 numbers in the statement for i = 1, 5 do . When you provide 2 numbers, the for loop in question will assume you are attempting to count up by increments of 1 (1, 2, 3, 4, 5) . You can override this behavior by providing a 3rd number, otherwise known as the increment. When you do so, your loop will instead start counting up in that increment. Code Output for i = 1 , 5 , 2 do print ( i ) end 1 3 5 In the example below, we have provided 2 as the increment. This tells the for loop to start counting up by 2 instead of the default 1. You can even apply this to have your for loop count DOWNWARDS. Code Output for i = 5 , 1 , - 1 do print ( i ) end 5 4 3 2 1 Warning An increment of 0 results in an infinite loop as the for loop never reaches the end value!","title":"For loop increments"},{"location":"Luau-Learning/basic_loops/#repeat-loops","text":"repeat loops run the code, and then checks if the until condition is true. If it is NOT true, the loop repeats until the condition is true. This behaves very similarly to a while loop. However, a while loop checks its condition first. A repeat loop runs the code first, before checking its condition. A good way of phrasing this will be like so: \"while this is true, do this\" / \"check first, then do\" \"repeat doing this until this is true\" / \"do first, then check\" Code Output local i = 0 repeat i = i + 1 print ( i ) until i > 5 1 2 3 4 5 6 Notice the inequality sign (>) in the until statement. This can be interpreted as \"add 1 to i, then check if i is above 5. If yes, don't repeat anymore. Else, repeat.\" Code Output local i = 0 while i < 5 do i = i + 1 print ( i ) end 1 2 3 4 5 Notice the inequality sign (<) in the while statement, which is different from that in the repeat loop above. This can be interpreted as \"check if i is above 5. If yes, repeat. Else, skip and do not loop anymore.\" This is also why the while loop doesn't print 6, while the repeat loop does.","title":"Repeat loops"},{"location":"Luau-Learning/basic_loops/#closing","text":"Loops are very powerful constructs that let you repeatedly run a set of instructions with minimal copy and paste. This makes your code easy to read and edit and also gives you more control over it. Where applicable, use the appropriate ones as much as possible!","title":"Closing"},{"location":"Luau-Learning/basics_of_properties/","text":"Properties Properties are a very key aspect in instances and Roblox programming. A property is an aspect of an Instance which can be changed. Using Properties Properties are very important and can be used in multiple ways. Here's how to access property and edit a property. Here I'll be changing the properties of a part via script. local Part = workspace . Part / Instance . new ( 'Part' ) -- Example Part . Name = 'Part' -- We use . to get a property Part . Parent = workspace Part . BrickColor = BrickColor . new ( 'Really Red' ) Common Mistakes Made When Using Properties Lots of new scripters commonly make the mistake of Indirect Changes . An indirect change is where you change the value of a Variable but not the value of your property. Code Output local Cash = Player . leaderstats . Cash . Value -- 25 Cash = 50 print ( Cash ) print ( Player . leaderstats . Cash . Value ) 50 25 The reason didn't work is because when we want to change something like this we have to access the value directly. Correct way of doing this Code Output local Cash = Player . leaderstats . Cash Cash . Value = 50 print ( Cash ) print ( Player . leaderstats . Cash . Value ) 50 50 How to use properties outside of scripts Firstly, make sure you have the properties tab enabled. If you don't, click the view tab at the top of roblox studio and click on properties(near the left). Once that is enabled you can change the properties of anything! Click on the instance you want to change and look at the properties menu. Loads of things are waiting to be changed to your liking. Changing basic properties For this section, we'll be changing some common properties of a part. Firstly, we'll change the brickcolor and size properties. This can be easily done by local part = workspace . Part --changing brickcolor part . BrickColor = BrickColor . new ( \"Really red\" ) --changing size part . Size = Vector3 . new ( 10 , 10 , 10 ) Those are just some basic things you can change with properties! Common properties Here are some common properties that every Instance should have. . Name . Parent . Archivable . ClassName GetPropertyChangedSignal GetPropertyChangedSignal is an event to detect whenever a property is changed. I'll be demonstrating a part for this local Part = Instance . new ( 'Part' ) / workspace . Part Part : GetPropertyChangedSignal ( 'Name' ): Connect ( function () print ( Part . Name ) -- SalzuIsCool,EdenIsBest end ) Part . Name = 'SalzuIsCool' Part . Name = 'EdenIsBest' Closing Thanks for reading my article. Please remember to report any errors found!","title":"Properties"},{"location":"Luau-Learning/basics_of_properties/#properties","text":"Properties are a very key aspect in instances and Roblox programming. A property is an aspect of an Instance which can be changed.","title":"Properties"},{"location":"Luau-Learning/basics_of_properties/#using-properties","text":"Properties are very important and can be used in multiple ways. Here's how to access property and edit a property. Here I'll be changing the properties of a part via script. local Part = workspace . Part / Instance . new ( 'Part' ) -- Example Part . Name = 'Part' -- We use . to get a property Part . Parent = workspace Part . BrickColor = BrickColor . new ( 'Really Red' )","title":"Using Properties"},{"location":"Luau-Learning/basics_of_properties/#common-mistakes-made-when-using-properties","text":"Lots of new scripters commonly make the mistake of Indirect Changes . An indirect change is where you change the value of a Variable but not the value of your property. Code Output local Cash = Player . leaderstats . Cash . Value -- 25 Cash = 50 print ( Cash ) print ( Player . leaderstats . Cash . Value ) 50 25 The reason didn't work is because when we want to change something like this we have to access the value directly. Correct way of doing this Code Output local Cash = Player . leaderstats . Cash Cash . Value = 50 print ( Cash ) print ( Player . leaderstats . Cash . Value ) 50 50","title":"Common Mistakes Made When Using Properties"},{"location":"Luau-Learning/basics_of_properties/#how-to-use-properties-outside-of-scripts","text":"Firstly, make sure you have the properties tab enabled. If you don't, click the view tab at the top of roblox studio and click on properties(near the left). Once that is enabled you can change the properties of anything! Click on the instance you want to change and look at the properties menu. Loads of things are waiting to be changed to your liking.","title":"How to use properties outside of scripts"},{"location":"Luau-Learning/basics_of_properties/#changing-basic-properties","text":"For this section, we'll be changing some common properties of a part. Firstly, we'll change the brickcolor and size properties. This can be easily done by local part = workspace . Part --changing brickcolor part . BrickColor = BrickColor . new ( \"Really red\" ) --changing size part . Size = Vector3 . new ( 10 , 10 , 10 ) Those are just some basic things you can change with properties!","title":"Changing basic properties"},{"location":"Luau-Learning/basics_of_properties/#common-properties","text":"Here are some common properties that every Instance should have. . Name . Parent . Archivable . ClassName","title":"Common properties"},{"location":"Luau-Learning/basics_of_properties/#getpropertychangedsignal","text":"GetPropertyChangedSignal is an event to detect whenever a property is changed. I'll be demonstrating a part for this local Part = Instance . new ( 'Part' ) / workspace . Part Part : GetPropertyChangedSignal ( 'Name' ): Connect ( function () print ( Part . Name ) -- SalzuIsCool,EdenIsBest end ) Part . Name = 'SalzuIsCool' Part . Name = 'EdenIsBest'","title":"GetPropertyChangedSignal"},{"location":"Luau-Learning/basics_of_properties/#closing","text":"Thanks for reading my article. Please remember to report any errors found!","title":"Closing"},{"location":"Luau-Learning/globals/","text":"Global Functions Global functions in lua are the built-in funcions which are pre declared and are very useful. There are many of them but in this guide we will discuss some common global functions. tonumber() tonumber(value,base) It converts the given argument in to a number of desired base (between 2-36). If second argument is missing then by default it converts the given argument into a number of base 10. In case of failure will return nil . Example Code: Output print ( tonumber ( \"123\" )) print ( tonumber ( \"911\" )) print ( tonumber ( \"abc\" )) 123 911 nil tostring() tostring(value) It converts the given argument in to a string . Just like tonumber() , If it cannot convert it will return nil . Example Code: Output print ( \"The statement was \" .. tostring ( true )) print ( \"Square of 16 is : \" .. tostring ( 16 ^ 2 )) The statement was true Square of 16 is : 256 print() print(value) It takes multiple arguments and display them in the console/output. In most cases it is used for debugging. Example Code: Output print ( \"Eden is smart\" ) print ( \"Helpers are the best\" ) Eden is smart Helpers are the best assert() assert(statement,error message) It stops the thread and returns the error message if the given statement is false or nil . Example Code: Output local eden = \"Brilliant\" assert ( eden == \"noob\" , \"eden is not noob\" ) eden is not noob error() error(message) It stops the curent thread and gives the error in the output/console. Example Code: Output error ( \"Program terminated!\" ) Program terminated! type() type(value) It returns the data type of the given argument. Example Code: Output local hi = true local data = { \"EdenRose\" , \"Teddy\" , \"Cake\" , \"Selfish\" } print ( type ( hi )) print ( type ( data )) boolean table pcall() pcall(function,...) It calls the given function in protected mode. In case of any error the thread will not be terminated. The first returned value is a bool which is either true or false depends if the call succeeded or not. If the call succeed then first value will be true and second value will be the value returned by the function called in the protected mode. If the call could not succeed then pcall will return false with the error message. Example Code: Output local function test ( name ) print ( name ) assert ( name == \"EdenRose\" , \"Incorrect Name!\" ) end local status , result = pcall ( test , \"Willie\" ) print ( status , result ) false Incorrect Name! unpack() unpack(table,initial_index,final_index) It returns elements of a table in the form of tuple , according to the given arguments. By default: initial_index = 1 final_index = #table Example Code: Output local tbl = { \"EdenRose\" , \"Teddy\" , \"Cake\" , \"Selfish\" , \"Smart\" , \"Intelligent\" } print ( unpack ( tbl , 2 , 5 )) Teddy Cake Selfish Smart select() select(n,args) If n is positive, It returns all the given arguments after the index n If n is negative, It returns all the given n number of arguments from the end if n is # operator, It returns the number of given arguments Example Code: Output print ( select ( \"#\" , \"hi\" , \"good\" , \"ok\" , \"wow\" , \"yep\" )) 5 rawequal() rawequal(value1,value2) It returns a bool value. If given arguments are equal, it returns true . If the arguments are not equal, it returns false Example Code: Output print ( rawequal ( 2 , 2 )) true Thanks For Reading :) In case of any mistake feel free to report this article!","title":"Lua Globals"},{"location":"Luau-Learning/globals/#global-functions","text":"Global functions in lua are the built-in funcions which are pre declared and are very useful. There are many of them but in this guide we will discuss some common global functions.","title":"Global Functions"},{"location":"Luau-Learning/globals/#tonumber","text":"tonumber(value,base) It converts the given argument in to a number of desired base (between 2-36). If second argument is missing then by default it converts the given argument into a number of base 10. In case of failure will return nil . Example Code: Output print ( tonumber ( \"123\" )) print ( tonumber ( \"911\" )) print ( tonumber ( \"abc\" )) 123 911 nil","title":"tonumber()"},{"location":"Luau-Learning/globals/#tostring","text":"tostring(value) It converts the given argument in to a string . Just like tonumber() , If it cannot convert it will return nil . Example Code: Output print ( \"The statement was \" .. tostring ( true )) print ( \"Square of 16 is : \" .. tostring ( 16 ^ 2 )) The statement was true Square of 16 is : 256","title":"tostring()"},{"location":"Luau-Learning/globals/#print","text":"print(value) It takes multiple arguments and display them in the console/output. In most cases it is used for debugging. Example Code: Output print ( \"Eden is smart\" ) print ( \"Helpers are the best\" ) Eden is smart Helpers are the best","title":"print()"},{"location":"Luau-Learning/globals/#assert","text":"assert(statement,error message) It stops the thread and returns the error message if the given statement is false or nil . Example Code: Output local eden = \"Brilliant\" assert ( eden == \"noob\" , \"eden is not noob\" ) eden is not noob","title":"assert()"},{"location":"Luau-Learning/globals/#error","text":"error(message) It stops the curent thread and gives the error in the output/console. Example Code: Output error ( \"Program terminated!\" ) Program terminated!","title":"error()"},{"location":"Luau-Learning/globals/#type","text":"type(value) It returns the data type of the given argument. Example Code: Output local hi = true local data = { \"EdenRose\" , \"Teddy\" , \"Cake\" , \"Selfish\" } print ( type ( hi )) print ( type ( data )) boolean table","title":"type()"},{"location":"Luau-Learning/globals/#pcall","text":"pcall(function,...) It calls the given function in protected mode. In case of any error the thread will not be terminated. The first returned value is a bool which is either true or false depends if the call succeeded or not. If the call succeed then first value will be true and second value will be the value returned by the function called in the protected mode. If the call could not succeed then pcall will return false with the error message. Example Code: Output local function test ( name ) print ( name ) assert ( name == \"EdenRose\" , \"Incorrect Name!\" ) end local status , result = pcall ( test , \"Willie\" ) print ( status , result ) false Incorrect Name!","title":"pcall()"},{"location":"Luau-Learning/globals/#unpack","text":"unpack(table,initial_index,final_index) It returns elements of a table in the form of tuple , according to the given arguments. By default: initial_index = 1 final_index = #table Example Code: Output local tbl = { \"EdenRose\" , \"Teddy\" , \"Cake\" , \"Selfish\" , \"Smart\" , \"Intelligent\" } print ( unpack ( tbl , 2 , 5 )) Teddy Cake Selfish Smart","title":"unpack()"},{"location":"Luau-Learning/globals/#select","text":"select(n,args) If n is positive, It returns all the given arguments after the index n If n is negative, It returns all the given n number of arguments from the end if n is # operator, It returns the number of given arguments Example Code: Output print ( select ( \"#\" , \"hi\" , \"good\" , \"ok\" , \"wow\" , \"yep\" )) 5","title":"select()"},{"location":"Luau-Learning/globals/#rawequal","text":"rawequal(value1,value2) It returns a bool value. If given arguments are equal, it returns true . If the arguments are not equal, it returns false Example Code: Output print ( rawequal ( 2 , 2 )) true","title":"rawequal()"},{"location":"Luau-Learning/globals/#thanks-for-reading","text":"In case of any mistake feel free to report this article!","title":"Thanks For Reading :)"},{"location":"Luau-Learning/handling_events/","text":"Events on Roblox Studio Events are one of the most used objects in Roblox Studio, when scripting on the platform you will make encounters with them very frequently and I could say that you will use them more than once in your game, there is a problem with beginners not fully comprehending this so-called \"events\" and sometimes, they end up misusing them, that's why I decided to make this article. We are going to learn what exactly is an event, how to use it, how to NOT use it, and some good practices when using it. What is an event? An event, formally called an RBXScriptSignal or RobloxScriptSignal it's a Roblox object that calls user-made functions when a certain in-game event happens, you can use them to know whenever a part touches another, when the user began an input, when a frame gets rendered, and more! That's why events are used very frequently and you can't just ignore them, they are the main way of knowing when something happened and assigning code for when it does happen, you will need to use them sooner or later. Each instance type counts with their own events, for example, BaseParts have Touched and TouchEnded , services count with events too, Players service has the PlayerAdded and PlayerRemoving events, you can also create your own events with BindableEvents or make them from scratch in a script (after you understand how they work of course) Usage of an event Events have two methods which are the only way to use them, those methods are Connect and Wait . Connect method requires only one parameter which is the function to connect to the event, this will add the function to the listeners of the event, and it will be called when the event fires, the method also returns a so-called RBXScriptConnection or Connection which we are going to talk about later. RBXScriptSignal : Connect ( function () print ( \"Event fired!\" ) end ) Clarification when using Connect In this example script, we created an anonymous function inside the parenthesis and the function can't be accessed from any other part of the script, that's why you see a parenthesis after the end, to close the Connect method call, but if the function is going to be used multiple times independent of the event or just for the sake of readability you could assign the function to a variable and just pass it as an argument to the Connect method: local function Listener () print ( \"Event fired!\" ) end RBXScriptSignal : Connect ( Listener ) The Wait method yields the current thread when called, and it will resume it until the event gets fired, and if you didn't understand that, don't worry, you will in the future, but in basic words, it will pause the script and will wait until the event gets fired to resume it, this unlike the Connect method will only listen for the next time the event fires after calling the method, after that it will not listen to the event. print ( \"Waiting for event to fire!\" ) RBXScriptSignal : Wait () print ( \"Event fired!\" ) Information about Wait method You need to be very cautious when using the Wait method over events, if for some reason your event never fires let's say, because of the instance getting destroyed, your script will never resume. How an event works The way of how an event works it's very simple, it's just based on storing values, for visualizing it we can say that when calling the method Connect, the event will store the function passed as an argument to a listeners table returning the connection made, and when calling the Wait method it will pause the thread and will store it on another table. graph LR a[Call] --- b[Connect] b --- c[Store function in table] c --- d[Return connection] a --- e[Wait] e --- f[Yield thread] f --- g[Store thread in table] After that, when the event gets fired it will only need to look for every function in the listeners table and call it, the same with threads, look for every thread in the table and resume it returning what the event does return. graph LR a[Fire] --- b[Listeners] b --- c[Call every function] a --- d[Threads] d --- e[Resume every thread] e --- f[Return values] This of course accounts for Filtering Enabled. Events as mentioned earlier can return or pass values depending on the situation, for example, the BasePart's Touched event passes the other part that touched our part as an argument to the connected functions, and returns it to the Wait call, knowing this we can do: BasePart . Touched : Connect ( function ( otherPart ) print ( otherPart . Name .. \" touched our BasePart\" ) end ) local otherPart = BasePart . Touched : Wait () print ( otherPart . Name .. \" touched our BasePart\" ) For knowing what does an event returns we recommend you check Roblox's API reference. Events are not if statements! The most common error that beginners do when using events is using them as if they were if statements nesting them like this: event1 : Connect ( function () event2 : Connect ( function () ... end ) end ) Or even using them like this: while true do wait () event : Connect ( function () ... end ) end This is completely wrong, and it's considered a misuse of events! Why? Well it's simple, the ones who wrote the code above may be misunderstanding what events are used for and they are using them to check if something happened and, as we said, their purpose is not that. For the first problem we can say, as we saw, when calling the Connect method the event will create a connection and return it to us, this means that every time the first event fires, a new connection for the second event will get create, this will lead to the code running many times, so if for example the first event ran five times, when the second event fires, the function will get called ten times! And not also that, if we are using anonymous functions (like in our case) we are going to be creating a new function every time and also as we have no reference for the connection of the second event we have no way of this to stop! A simple solution for this, would be using actual if statements and not nesting the events, for example: local checkVariable = false event1 : Connect ( function () checkVariable = true end ) event2 : Connect ( function () if checkVariable then ... end end ) This will depend on every case, but in general, this is what most people try to do. Disconnecting our connections As we said earlier, Connect method returns a RBXScriptConnection or Connection, this datatype or object contains one but powerful method, which is Disconnect and as you guessed, when it gets called it disconnects the listener function from the event, the exact opposite thing that Connect does. You may be asking \"Why would be this useful?\" well, let me explain to you creating another solution for the first problem above. local connection -- Initializes the variable on nil event1 : Connect ( function () if not connection then -- If connection it's nil connection = event2 : Connect ( function () -- We set our connection ... connection : Disconnect () -- We disconnect our connection end end end ) This may not be the best solution but for the sake of explaining to you what disconnect does, I think it's pretty good, disconnecting a connection when the event it's not going to be used again or similar it's a good practice, since it can avoid us to memory leaks and other weird stuff that could happen in the background; this of course it's not necessary all the times because for example, when an instance gets destroyed, all the connections do too. Memory leaks As we mentioned above, not disconnecting events in some cases can lead to more memory usage, or memory leaks, lets take as example the second problem mentioned above; every 1/30 seconds we are creating a new connection for the event, this is not good because we are using more memory for storing those connections and all of that stuff, now if you run some code like that, eventually you will see that, when time passes your game can increase its activity, or even experience lag spikes or poor performance, so if your game it's experiencing some of those problems you may want to look over your events and handle them better Thanks for reading Thanks for reading the article and I hope you understood how to use events, how they work and some good practices.","title":"Understanding events"},{"location":"Luau-Learning/handling_events/#events-on-roblox-studio","text":"Events are one of the most used objects in Roblox Studio, when scripting on the platform you will make encounters with them very frequently and I could say that you will use them more than once in your game, there is a problem with beginners not fully comprehending this so-called \"events\" and sometimes, they end up misusing them, that's why I decided to make this article. We are going to learn what exactly is an event, how to use it, how to NOT use it, and some good practices when using it.","title":"Events on Roblox Studio"},{"location":"Luau-Learning/handling_events/#what-is-an-event","text":"An event, formally called an RBXScriptSignal or RobloxScriptSignal it's a Roblox object that calls user-made functions when a certain in-game event happens, you can use them to know whenever a part touches another, when the user began an input, when a frame gets rendered, and more! That's why events are used very frequently and you can't just ignore them, they are the main way of knowing when something happened and assigning code for when it does happen, you will need to use them sooner or later. Each instance type counts with their own events, for example, BaseParts have Touched and TouchEnded , services count with events too, Players service has the PlayerAdded and PlayerRemoving events, you can also create your own events with BindableEvents or make them from scratch in a script (after you understand how they work of course)","title":"What is an event?"},{"location":"Luau-Learning/handling_events/#usage-of-an-event","text":"Events have two methods which are the only way to use them, those methods are Connect and Wait . Connect method requires only one parameter which is the function to connect to the event, this will add the function to the listeners of the event, and it will be called when the event fires, the method also returns a so-called RBXScriptConnection or Connection which we are going to talk about later. RBXScriptSignal : Connect ( function () print ( \"Event fired!\" ) end ) Clarification when using Connect In this example script, we created an anonymous function inside the parenthesis and the function can't be accessed from any other part of the script, that's why you see a parenthesis after the end, to close the Connect method call, but if the function is going to be used multiple times independent of the event or just for the sake of readability you could assign the function to a variable and just pass it as an argument to the Connect method: local function Listener () print ( \"Event fired!\" ) end RBXScriptSignal : Connect ( Listener ) The Wait method yields the current thread when called, and it will resume it until the event gets fired, and if you didn't understand that, don't worry, you will in the future, but in basic words, it will pause the script and will wait until the event gets fired to resume it, this unlike the Connect method will only listen for the next time the event fires after calling the method, after that it will not listen to the event. print ( \"Waiting for event to fire!\" ) RBXScriptSignal : Wait () print ( \"Event fired!\" ) Information about Wait method You need to be very cautious when using the Wait method over events, if for some reason your event never fires let's say, because of the instance getting destroyed, your script will never resume.","title":"Usage of an event"},{"location":"Luau-Learning/handling_events/#how-an-event-works","text":"The way of how an event works it's very simple, it's just based on storing values, for visualizing it we can say that when calling the method Connect, the event will store the function passed as an argument to a listeners table returning the connection made, and when calling the Wait method it will pause the thread and will store it on another table. graph LR a[Call] --- b[Connect] b --- c[Store function in table] c --- d[Return connection] a --- e[Wait] e --- f[Yield thread] f --- g[Store thread in table] After that, when the event gets fired it will only need to look for every function in the listeners table and call it, the same with threads, look for every thread in the table and resume it returning what the event does return. graph LR a[Fire] --- b[Listeners] b --- c[Call every function] a --- d[Threads] d --- e[Resume every thread] e --- f[Return values] This of course accounts for Filtering Enabled. Events as mentioned earlier can return or pass values depending on the situation, for example, the BasePart's Touched event passes the other part that touched our part as an argument to the connected functions, and returns it to the Wait call, knowing this we can do: BasePart . Touched : Connect ( function ( otherPart ) print ( otherPart . Name .. \" touched our BasePart\" ) end ) local otherPart = BasePart . Touched : Wait () print ( otherPart . Name .. \" touched our BasePart\" ) For knowing what does an event returns we recommend you check Roblox's API reference.","title":"How an event works"},{"location":"Luau-Learning/handling_events/#events-are-not-if-statements","text":"The most common error that beginners do when using events is using them as if they were if statements nesting them like this: event1 : Connect ( function () event2 : Connect ( function () ... end ) end ) Or even using them like this: while true do wait () event : Connect ( function () ... end ) end This is completely wrong, and it's considered a misuse of events! Why? Well it's simple, the ones who wrote the code above may be misunderstanding what events are used for and they are using them to check if something happened and, as we said, their purpose is not that. For the first problem we can say, as we saw, when calling the Connect method the event will create a connection and return it to us, this means that every time the first event fires, a new connection for the second event will get create, this will lead to the code running many times, so if for example the first event ran five times, when the second event fires, the function will get called ten times! And not also that, if we are using anonymous functions (like in our case) we are going to be creating a new function every time and also as we have no reference for the connection of the second event we have no way of this to stop! A simple solution for this, would be using actual if statements and not nesting the events, for example: local checkVariable = false event1 : Connect ( function () checkVariable = true end ) event2 : Connect ( function () if checkVariable then ... end end ) This will depend on every case, but in general, this is what most people try to do.","title":"Events are not if statements!"},{"location":"Luau-Learning/handling_events/#disconnecting-our-connections","text":"As we said earlier, Connect method returns a RBXScriptConnection or Connection, this datatype or object contains one but powerful method, which is Disconnect and as you guessed, when it gets called it disconnects the listener function from the event, the exact opposite thing that Connect does. You may be asking \"Why would be this useful?\" well, let me explain to you creating another solution for the first problem above. local connection -- Initializes the variable on nil event1 : Connect ( function () if not connection then -- If connection it's nil connection = event2 : Connect ( function () -- We set our connection ... connection : Disconnect () -- We disconnect our connection end end end ) This may not be the best solution but for the sake of explaining to you what disconnect does, I think it's pretty good, disconnecting a connection when the event it's not going to be used again or similar it's a good practice, since it can avoid us to memory leaks and other weird stuff that could happen in the background; this of course it's not necessary all the times because for example, when an instance gets destroyed, all the connections do too.","title":"Disconnecting our connections"},{"location":"Luau-Learning/handling_events/#memory-leaks","text":"As we mentioned above, not disconnecting events in some cases can lead to more memory usage, or memory leaks, lets take as example the second problem mentioned above; every 1/30 seconds we are creating a new connection for the event, this is not good because we are using more memory for storing those connections and all of that stuff, now if you run some code like that, eventually you will see that, when time passes your game can increase its activity, or even experience lag spikes or poor performance, so if your game it's experiencing some of those problems you may want to look over your events and handle them better","title":"Memory leaks"},{"location":"Luau-Learning/handling_events/#thanks-for-reading","text":"Thanks for reading the article and I hope you understood how to use events, how they work and some good practices.","title":"Thanks for reading"},{"location":"Luau-Learning/metatables/","text":"Pre-requisites Before reading this tutorial, you should know about tables. An explanation of tables exists in the Lua-Learning folder. What's a metatable? Metatables allow tables to become more powerful. Any table can have a metatable and they can hold metamethods, which are similar to events. I like to call them table-events. Use cases for metatables Metatables are often used to simulate Object Oriented Programming, but aren't essential to that. Using setmetatable() setmetatable() is a global function by Lua that you can use to set a metatable to a table. It takes in the table as the first argument and the metatable as the second. local normalTable = {} local metaTable = {} setmetatable ( normalTable , metaTable ) --metaTable is the metatable of our normalTable now! setmetatable() also returns the table the metatable was set to, we don't really need it in this example though. Common misunderstanding: Often, people think that the table becomes the metatable. That isn't true. Instead, imagine the metatable as an addition to the table. Explanation of metamethods using __index The power of metatables comes from their metamethods. You can see a list of all the metamethods here . We will be using __index now. __index fires, when nil is indexed in our table. We could set __index to another table for example and it would search through that. local fruits = { Apple = \"red\" , Banana = \"yellow\" , Orange = \"orange\" } local normalTable = {} local metaTable = {} metaTable . __index = fruits setmetatable ( normalTable , metaTable ) print ( normalTable . Apple ) --> red The reason this prints out red is because our __index metamethod leads it to our fruits dictionary. Here a visualization of what is happening: normalTable.Apple --> nil --> does the table have a metatable? Yes --> does that metatable have an __index metamethod? Yes --> use that to return a value. We could also store the fruits inside of our metaTable, we would just have to set our __index to our metatable. local normalTable = {} local metaTable = { Apple = \"red\" , Banana = \"yellow\" , Orange = \"orange\" } metaTable . __index = metaTable setmetatable ( normalTable , metaTable ) print ( normalTable . Apple ) --> red A metatable can have many different metamethods, it isn't limited to one. Let's set our index to a function and see what happens! local normalTable = {} local metaTable = {} metaTable . __index = function () print ( \"Tried to index nil!\" ) end setmetatable ( normalTable , metaTable ) local value = normalTable . Apple --> Tried to index nil! You can also return something inside of the function. local normalTable = {} local metaTable = {} metaTable . __index = function () return \"Tried to index nil!\" end setmetatable ( normalTable , metaTable ) print ( normalTable . Apple ) --> Tried to index nil! Apart from that, __index and most of the other metamethods also pass parameters. __index passes the table that's trying to be indexed and the index that was not found. local normalTable = {} local metaTable = {} metaTable . __index = function ( indexedTable , invalidIndex ) return \"Tried to index \" .. invalidIndex .. \" inside of \" .. tostring ( indexedTable ) --tostring so it doesn't error end setmetatable ( normalTable , metaTable ) print ( normalTable . Apple ) --> Tried to index Apple inside of table: 0x8e801614244a0fbb As far as I know though, setting a function to __index is quite expensive. Changed event for tables using __newindex Now that we roughly know about metatables and metamethods, we can try scripting a Changed event for tables and learn about a new metamethod: __newindex __newindex fires, whenever you are trying to set a new value in a table: local normalTable = {} local metaTable = {} metaTable . __newindex = function () print ( \"Trying to set a new value\" ) end setmetatable ( normalTable , metaTable ) normalTable . Apple = \"red\" --> Trying to set a new value It actually stops it from setting Apple to red, so trying to print normalTable.Apple will return nil, or if you have an __index metamethod, fire that. The problem with this is, that it doesn't account for changes, only new values being set. The most common workaround probably is making a table that is empty, and inside of the function, change our actual table's values: local realTable = { Money = 5 } local emptyTable = {} local metaTable = {} metaTable . __newindex = function ( table , index , value ) print ( \"Trying to set a new value\" ) end setmetatable ( emptyTable , metaTable ) __newindex passes the table, index and value as parameters. We don't really care about the table because we already know it's emptyTable, we only care about the index and value. We will check if in our realTable, setting index to value would be a change, and if so, print out \"changed\" local realTable = { Money = 5 } local emptyTable = {} local metaTable = {} metaTable . __newindex = function ( table , index , value ) if realTable [ index ] ~= value then realTable [ index ] = value print ( \"Changed\" ) end end setmetatable ( emptyTable , metaTable ) We also have to set index to the value in our realTable. With that, we've scripted a Changed event for tables! Thanks for reading! There is much more to metatables, of course, I didn't want this tutorial to be too long. If you want to learn more about them, I recommend these tutorials: DevHub's article on metatables Starmaq's tutorial on DevForum","title":"Metatables"},{"location":"Luau-Learning/metatables/#pre-requisites","text":"Before reading this tutorial, you should know about tables. An explanation of tables exists in the Lua-Learning folder.","title":"Pre-requisites"},{"location":"Luau-Learning/metatables/#whats-a-metatable","text":"Metatables allow tables to become more powerful. Any table can have a metatable and they can hold metamethods, which are similar to events. I like to call them table-events.","title":"What's a metatable?"},{"location":"Luau-Learning/metatables/#use-cases-for-metatables","text":"Metatables are often used to simulate Object Oriented Programming, but aren't essential to that.","title":"Use cases for metatables"},{"location":"Luau-Learning/metatables/#using-setmetatable","text":"setmetatable() is a global function by Lua that you can use to set a metatable to a table. It takes in the table as the first argument and the metatable as the second. local normalTable = {} local metaTable = {} setmetatable ( normalTable , metaTable ) --metaTable is the metatable of our normalTable now! setmetatable() also returns the table the metatable was set to, we don't really need it in this example though. Common misunderstanding: Often, people think that the table becomes the metatable. That isn't true. Instead, imagine the metatable as an addition to the table.","title":"Using setmetatable()"},{"location":"Luau-Learning/metatables/#explanation-of-metamethods-using-__index","text":"The power of metatables comes from their metamethods. You can see a list of all the metamethods here . We will be using __index now. __index fires, when nil is indexed in our table. We could set __index to another table for example and it would search through that. local fruits = { Apple = \"red\" , Banana = \"yellow\" , Orange = \"orange\" } local normalTable = {} local metaTable = {} metaTable . __index = fruits setmetatable ( normalTable , metaTable ) print ( normalTable . Apple ) --> red The reason this prints out red is because our __index metamethod leads it to our fruits dictionary. Here a visualization of what is happening: normalTable.Apple --> nil --> does the table have a metatable? Yes --> does that metatable have an __index metamethod? Yes --> use that to return a value. We could also store the fruits inside of our metaTable, we would just have to set our __index to our metatable. local normalTable = {} local metaTable = { Apple = \"red\" , Banana = \"yellow\" , Orange = \"orange\" } metaTable . __index = metaTable setmetatable ( normalTable , metaTable ) print ( normalTable . Apple ) --> red A metatable can have many different metamethods, it isn't limited to one. Let's set our index to a function and see what happens! local normalTable = {} local metaTable = {} metaTable . __index = function () print ( \"Tried to index nil!\" ) end setmetatable ( normalTable , metaTable ) local value = normalTable . Apple --> Tried to index nil! You can also return something inside of the function. local normalTable = {} local metaTable = {} metaTable . __index = function () return \"Tried to index nil!\" end setmetatable ( normalTable , metaTable ) print ( normalTable . Apple ) --> Tried to index nil! Apart from that, __index and most of the other metamethods also pass parameters. __index passes the table that's trying to be indexed and the index that was not found. local normalTable = {} local metaTable = {} metaTable . __index = function ( indexedTable , invalidIndex ) return \"Tried to index \" .. invalidIndex .. \" inside of \" .. tostring ( indexedTable ) --tostring so it doesn't error end setmetatable ( normalTable , metaTable ) print ( normalTable . Apple ) --> Tried to index Apple inside of table: 0x8e801614244a0fbb As far as I know though, setting a function to __index is quite expensive.","title":"Explanation of metamethods using __index"},{"location":"Luau-Learning/metatables/#changed-event-for-tables-using-__newindex","text":"Now that we roughly know about metatables and metamethods, we can try scripting a Changed event for tables and learn about a new metamethod: __newindex __newindex fires, whenever you are trying to set a new value in a table: local normalTable = {} local metaTable = {} metaTable . __newindex = function () print ( \"Trying to set a new value\" ) end setmetatable ( normalTable , metaTable ) normalTable . Apple = \"red\" --> Trying to set a new value It actually stops it from setting Apple to red, so trying to print normalTable.Apple will return nil, or if you have an __index metamethod, fire that. The problem with this is, that it doesn't account for changes, only new values being set. The most common workaround probably is making a table that is empty, and inside of the function, change our actual table's values: local realTable = { Money = 5 } local emptyTable = {} local metaTable = {} metaTable . __newindex = function ( table , index , value ) print ( \"Trying to set a new value\" ) end setmetatable ( emptyTable , metaTable ) __newindex passes the table, index and value as parameters. We don't really care about the table because we already know it's emptyTable, we only care about the index and value. We will check if in our realTable, setting index to value would be a change, and if so, print out \"changed\" local realTable = { Money = 5 } local emptyTable = {} local metaTable = {} metaTable . __newindex = function ( table , index , value ) if realTable [ index ] ~= value then realTable [ index ] = value print ( \"Changed\" ) end end setmetatable ( emptyTable , metaTable ) We also have to set index to the value in our realTable. With that, we've scripted a Changed event for tables!","title":"Changed event for tables using __newindex"},{"location":"Luau-Learning/metatables/#thanks-for-reading","text":"There is much more to metatables, of course, I didn't want this tutorial to be too long. If you want to learn more about them, I recommend these tutorials: DevHub's article on metatables Starmaq's tutorial on DevForum","title":"Thanks for reading!"},{"location":"Luau-Learning/modules/","text":"What Is A Module Script? What is a ModuleScript ? A module script can host data such as a table, function, strings, and numbers. Anything. But, a Module Script can only return one data value. Depending on what the module script is doing, handling server code/handling client code can go in ServerScriptService or ReplicatedStorage . Localized code for ReplicatedStorage and server code for ServerScriptService. Module scripts will run code on the side they're called from if that makes sense. If you call a module script from a local script the module script will be running localized code. Thereby you would have access to the LocalPlayer. Why Use Module Scripts Over Normal Scripts As a beginner, your main reason to use module scripts over normal scripts is for functions that you need to use in more than one script. For example, giving a player coins each time they do something. Having a module script with a coin function that gives the Player coins. Module scripts can also be useful to store data. If you have a Twitter code system you can store the codes in that module script with the number of coins they give. How Do You Use Module Scripts Module scripts won't run any code unless you require them. So how do you require a module script? It's quite simple. Firstly though, we're going to make a Module Script inside of ReplicatedStorage. Inside of this, we're going to add a print when the module script is required and we're going to return a table. local ModuleScript = { SalzuIsTheBest = 'SalzuIsTheBest' } print ( 'This module script has been required' ) return ModuleScript Then in a server script, we're going to require the module script. It will print \"This module script has been required\". local MoudleScript = require ( game . ReplicatedStorage . MyModuleScript ) -- This module script has been required. print ( ModuleScript ) -- SalzuIsTheBest We then print the module script returning a table with the value \"SalzuIsTheBest\" Adding Variables/Functions To Your Module Script Now we're going to talk about how to add variables to your Module Script. This isn't how you always might want to do it. To add Values to a table you do: Table . MyValue = 10 You can add functions like that too: Table . Add = function ( A , B ) print ( A + B ) end --You can also add functions like this function Table . Add ( A , B ) print ( A + B ) end Scopes Within A Module Script Module scripts work differently. You don't always want to make a function localized, why? If the function is localized then other scripts you require won't be able to run the function. Now, this doesn't mean putting local in front of a function inside of a module script. Any variable/function that the module script only uses should be localized. Here I'll be showing right versus wrong. Right: function ModuleScript . Add ( A , B ) print ( A + B ) end Any script we require this module script in will be able to use that function. Wrong: local function ModuleScript . Add ( A , B ) print ( A + B ) end No other script will be able to use that function. Closing! That's pretty much of it. Hope you enjoyed reading it. In case of any mistake, typos, etc. Please report the article. You can also give us reviews here","title":"Module Scripts"},{"location":"Luau-Learning/modules/#what-is-a-module-script","text":"What is a ModuleScript ? A module script can host data such as a table, function, strings, and numbers. Anything. But, a Module Script can only return one data value. Depending on what the module script is doing, handling server code/handling client code can go in ServerScriptService or ReplicatedStorage . Localized code for ReplicatedStorage and server code for ServerScriptService. Module scripts will run code on the side they're called from if that makes sense. If you call a module script from a local script the module script will be running localized code. Thereby you would have access to the LocalPlayer.","title":"What Is A Module Script?"},{"location":"Luau-Learning/modules/#why-use-module-scripts-over-normal-scripts","text":"As a beginner, your main reason to use module scripts over normal scripts is for functions that you need to use in more than one script. For example, giving a player coins each time they do something. Having a module script with a coin function that gives the Player coins. Module scripts can also be useful to store data. If you have a Twitter code system you can store the codes in that module script with the number of coins they give.","title":"Why Use Module Scripts Over Normal Scripts"},{"location":"Luau-Learning/modules/#how-do-you-use-module-scripts","text":"Module scripts won't run any code unless you require them. So how do you require a module script? It's quite simple. Firstly though, we're going to make a Module Script inside of ReplicatedStorage. Inside of this, we're going to add a print when the module script is required and we're going to return a table. local ModuleScript = { SalzuIsTheBest = 'SalzuIsTheBest' } print ( 'This module script has been required' ) return ModuleScript Then in a server script, we're going to require the module script. It will print \"This module script has been required\". local MoudleScript = require ( game . ReplicatedStorage . MyModuleScript ) -- This module script has been required. print ( ModuleScript ) -- SalzuIsTheBest We then print the module script returning a table with the value \"SalzuIsTheBest\"","title":"How Do You Use Module Scripts"},{"location":"Luau-Learning/modules/#adding-variablesfunctions-to-your-module-script","text":"Now we're going to talk about how to add variables to your Module Script. This isn't how you always might want to do it. To add Values to a table you do: Table . MyValue = 10 You can add functions like that too: Table . Add = function ( A , B ) print ( A + B ) end --You can also add functions like this function Table . Add ( A , B ) print ( A + B ) end","title":"Adding Variables/Functions To Your Module Script"},{"location":"Luau-Learning/modules/#scopes-within-a-module-script","text":"Module scripts work differently. You don't always want to make a function localized, why? If the function is localized then other scripts you require won't be able to run the function. Now, this doesn't mean putting local in front of a function inside of a module script. Any variable/function that the module script only uses should be localized. Here I'll be showing right versus wrong. Right: function ModuleScript . Add ( A , B ) print ( A + B ) end Any script we require this module script in will be able to use that function. Wrong: local function ModuleScript . Add ( A , B ) print ( A + B ) end No other script will be able to use that function.","title":"Scopes Within A Module Script"},{"location":"Luau-Learning/modules/#closing","text":"That's pretty much of it. Hope you enjoyed reading it. In case of any mistake, typos, etc. Please report the article. You can also give us reviews here","title":"Closing!"},{"location":"Luau-Learning/more_about_functions/","text":"Intro: In this guide, we will discuss some more stuff about functions. Before proceeding make sure you have some knowledge about the function and conditional statements! Recursive Function What is recursion/recursive function? Recursion in Lua is very simple. In recursion, a function calls itself until a condition meets, just like a loop! Now you must be thinking about how a function can call itself? So there is an example of how you can do it! local function recursive ( n ) if n == 6 then return n end print ( n ) n = n + 1 return recursive ( n ) end recursive ( 1 ) Output: 1 2 3 4 5 In the above code, we created a recursive function. Firstly, it checks if the given argument is not 6 then it adds 1 to it and again calls the function. It repeats the process again and again until the n is equal to 6. example: You can use recursion for lots of stuff. To give you an example I made a recursive function that iterates through an array and prints its elements local tbl = { \"eden\" , \"blueberry\" , \"roblox\" , \"lua\" , \"kebabs\" } local function iterator ( tb , cur_ind ) local index = cur_ind or 0 local value = tb [ index + 1 ] print ( value ) return tb [ index + 2 ] and iterator ( index + 1 ) end iterator ( tbl ) Output: eden blueberry roblox lua kebabs Anonymous Functions! What is an anonymous function? Anonymous functions are just anonymous, It means that they have no name. We just create them anonymously. Let me give you an example local function func () return function () -- anonymous function end end In the above example the function func returns an anonymous function . You can cache this anonymous function and then call it. Closure Function! What is a closure? The closure could be a little complicated but I will try my best to explain you. The first thing you should always remember is: that a closure function is an anonymous function but an anonymous function is not always a closure function . I will try to explain you with an example! local function func () local number = 2 return function () -- a closure function number = number + 1 return number end end local v1 = func () print ( v1 ()) print ( v1 ()) Output: 3 4 Now you might be confused but no worry I will explain you! So, here are a few points you should know to understand that A closure function always has access to the variables (upvalues) of that function that returned this closure function. If a closure function updates any of those upvalues say it changed the upvalue from \"2\" to \"4\" , now whenever that closure function is called the value will be \"4\". Now if you look back on the code you might start understanding how a closure function works. In the example code, we created the function func . Inside the function, we created a variable number and store 1 in it. After that, we returned a closure function and inside closure, we added 1 in the number variable. We cached that closure function in a variable v1 . Now whenever we call it, it adds \"1\" to the number variable. For the first time when we called the closure function, the variable \"number\" had 2 in it. So, after adding it becomes 3 and returned 3. When the closure function was called for the second time the number variable had 3 in it and after adding it became 4. And that's how a closure function works. Hope you understand it now. If there s still any confusion try reading it again. You might be thinking the closure function is a useless thing but if you are thinking that then you are 200% wrong because closure functions are pretty useful and very important. Using closure you can make cool stuff. just to show you how much useful they are, I made an iterator function just like pairs/ipairs , and here it is: local function iter ( b ) local ins = 0 local s return function () ins += 1 return b [ ins ] and ins , b [ ins ] end end local tbl = { \"edenrose\" , \"hi\" , \"cute\" , \"alive\" } for i , v in iter ( tbl ) do print ( i , v ) end Output: 1 edenrose 2 hi 3 cute 4 alive Thanks For Reading! In case of any mistakes, please report the article, and don't forget to leave your reviews!","title":"More About Functions"},{"location":"Luau-Learning/more_about_functions/#intro","text":"In this guide, we will discuss some more stuff about functions. Before proceeding make sure you have some knowledge about the function and conditional statements!","title":"Intro:"},{"location":"Luau-Learning/more_about_functions/#recursive-function","text":"","title":"Recursive Function"},{"location":"Luau-Learning/more_about_functions/#what-is-recursionrecursive-function","text":"Recursion in Lua is very simple. In recursion, a function calls itself until a condition meets, just like a loop! Now you must be thinking about how a function can call itself? So there is an example of how you can do it! local function recursive ( n ) if n == 6 then return n end print ( n ) n = n + 1 return recursive ( n ) end recursive ( 1 ) Output: 1 2 3 4 5 In the above code, we created a recursive function. Firstly, it checks if the given argument is not 6 then it adds 1 to it and again calls the function. It repeats the process again and again until the n is equal to 6.","title":"What is recursion/recursive function?"},{"location":"Luau-Learning/more_about_functions/#example","text":"You can use recursion for lots of stuff. To give you an example I made a recursive function that iterates through an array and prints its elements local tbl = { \"eden\" , \"blueberry\" , \"roblox\" , \"lua\" , \"kebabs\" } local function iterator ( tb , cur_ind ) local index = cur_ind or 0 local value = tb [ index + 1 ] print ( value ) return tb [ index + 2 ] and iterator ( index + 1 ) end iterator ( tbl ) Output: eden blueberry roblox lua kebabs","title":"example:"},{"location":"Luau-Learning/more_about_functions/#anonymous-functions","text":"","title":"Anonymous Functions!"},{"location":"Luau-Learning/more_about_functions/#what-is-an-anonymous-function","text":"Anonymous functions are just anonymous, It means that they have no name. We just create them anonymously. Let me give you an example local function func () return function () -- anonymous function end end In the above example the function func returns an anonymous function . You can cache this anonymous function and then call it.","title":"What is an anonymous function?"},{"location":"Luau-Learning/more_about_functions/#closure-function","text":"","title":"Closure Function!"},{"location":"Luau-Learning/more_about_functions/#what-is-a-closure","text":"The closure could be a little complicated but I will try my best to explain you. The first thing you should always remember is: that a closure function is an anonymous function but an anonymous function is not always a closure function . I will try to explain you with an example! local function func () local number = 2 return function () -- a closure function number = number + 1 return number end end local v1 = func () print ( v1 ()) print ( v1 ()) Output: 3 4 Now you might be confused but no worry I will explain you! So, here are a few points you should know to understand that A closure function always has access to the variables (upvalues) of that function that returned this closure function. If a closure function updates any of those upvalues say it changed the upvalue from \"2\" to \"4\" , now whenever that closure function is called the value will be \"4\". Now if you look back on the code you might start understanding how a closure function works. In the example code, we created the function func . Inside the function, we created a variable number and store 1 in it. After that, we returned a closure function and inside closure, we added 1 in the number variable. We cached that closure function in a variable v1 . Now whenever we call it, it adds \"1\" to the number variable. For the first time when we called the closure function, the variable \"number\" had 2 in it. So, after adding it becomes 3 and returned 3. When the closure function was called for the second time the number variable had 3 in it and after adding it became 4. And that's how a closure function works. Hope you understand it now. If there s still any confusion try reading it again. You might be thinking the closure function is a useless thing but if you are thinking that then you are 200% wrong because closure functions are pretty useful and very important. Using closure you can make cool stuff. just to show you how much useful they are, I made an iterator function just like pairs/ipairs , and here it is: local function iter ( b ) local ins = 0 local s return function () ins += 1 return b [ ins ] and ins , b [ ins ] end end local tbl = { \"edenrose\" , \"hi\" , \"cute\" , \"alive\" } for i , v in iter ( tbl ) do print ( i , v ) end Output: 1 edenrose 2 hi 3 cute 4 alive","title":"What is a closure?"},{"location":"Luau-Learning/more_about_functions/#thanks-for-reading","text":"In case of any mistakes, please report the article, and don't forget to leave your reviews!","title":"Thanks For Reading!"},{"location":"Luau-Learning/operators/","text":"What are operators Operators are a set of symbols that you can use to do cool and quirky things. Logical operators The logical operators are and , or , not . These operators considers false and nil as \"false\" and everything else as \"true\". And and will evaluate as true if both conditions are true Code Output local trueStatement = ( 1 + 1 == 2 ) and ( 3 * 2 == 6 ) local falseStatement = ( 2 - 1 == 1 ) and ( 6 / 2 == 5 ) print ( trueStatement ) print ( falseStatement ) true false You can also use and to check a condition when assigning a value to a variable without using an if statement. Code Output local rightAnswer = ( 2 + 2 == 4 ) and \"right\" -- Since 2 + 2 is indeed 4, it will assign \"right\" to rightAnswer print ( rightAnswer ) right Or or will evaluate as true if one of the conditions are true Code Output local trueStatement = ( 2 + 2 == 69 ) or ( 2 * 2 == 4 ) -- One of these conditions are true, hence it will evaluate as true local falseStatement = ( 6 ^ 6 == 89 ) or ( 2 - 9 == - 420 ) -- Both conditions are false, hence it will evaluate as false print ( trueStatement ) print ( falseStatement ) true false Just like and , you can also use or when assigning values to variables. Code Output local answer = ( 2 + 2 == 5 ) and \"right\" or \"wtf wrong !!!!\" --[[ Since 2 + 2 is not 5, it will assign \"wtf wrong !!!!\" to answer, instead of assigning \"right\" to it. ]] print ( answer ) wtf wrong !!!! Not not will evaluate as the opposite of the condition. For example, not true --> false , not false --> true Code Output local trueStatement = ( 2 + 2 == 4 ) -- true local falseStatement = ( 2 + 2 == 5 ) -- false print ( not trueStatement ) print ( not falseStatement ) false true Relational Relational operators are used to compare 2 values and will return a boolean ( true or false ) Equal to (==) As the name suggests, this operator checks if one value is equal to another value. Code Output print ( 2 == 1 + 1 ) print ( 3 == 2 ) true false Not equal to (~=) This operator checks if one value does not equal to another value Code Output print ( \"joe\" ~= \"willie\" ) print ( 1 ~= 0 + 1 ) true false Greater than (>) This operator checks if one value is greater than to another value Code Output print ( 3 > 2 ) print ( - 1 > 4 ) true false Less than (<) This operator checks if one value is less than to another value Code Output print ( 2 < 3 ) print ( 4 < - 1 ) true false Greater than or equal to (>=) This operator checks if one value is great than or equal to to another value Code Output print ( 3 >= 1 ) print ( 3 >= 3 ) print ( 3 >= 5 ) true true false Less than or equal to (<=) This operator checks if one value is less than or equal to to another value Code Output print ( 1 <= 3 ) print ( 1 <= 1 ) print ( 5 <= 3 ) true true false Arithmetic Lua supports the usual binary operators along with exponentiation (^), modulus (%), and unary negation (-). These are pretty self explanatory, so I won't be providing any explanations. Addition (+) Code Output print ( 2 + 2 ) print ( 3 + 6 ) 4 9 Subtraction (-) Code Output print ( 4 - 2 ) print ( 5 - 2 ) 2 3 Multiplication (*) Code Output print ( 2 * 3 ) print ( 3 * 3 ) 6 9 Division (/) Code Output print ( 6 / 2 ) print ( 1 / 2 ) 3 0.5 Exponentiation (^) Code Output print ( 2 ^ 3 ) print ( 3 ^ 3 ) 8 27 Modulus (%) Code Output print ( 2 % 2 ) print ( 13 % 6 ) 0 1 Unary negation (-) Code Output print ( - 4 ) - 4 Miscellaneous Miscellaneous operators include concatenation and length . Concatenation (..) Concatenates 2 values together. You can only concatenate strings and numbers Code Output print ( \"hello \" .. \"world!!!!\" ) hello world !!!! Length (#) If used on a table, specifically an array , it will return the number of elements in that array. If used on a string , it will return the amount of characters in that string, spaces are counted too Code Output local array = { 1 , 5 , 6 , 8 , 9 } local leString = \"hellooo\" print ( # array ) print ( # leString ) 5 7 Thanks for reading !!! If there are any mistakes found in this article, please report the artcile!","title":"Operators"},{"location":"Luau-Learning/operators/#what-are-operators","text":"Operators are a set of symbols that you can use to do cool and quirky things.","title":"What are operators"},{"location":"Luau-Learning/operators/#logical-operators","text":"The logical operators are and , or , not . These operators considers false and nil as \"false\" and everything else as \"true\".","title":"Logical operators"},{"location":"Luau-Learning/operators/#and","text":"and will evaluate as true if both conditions are true Code Output local trueStatement = ( 1 + 1 == 2 ) and ( 3 * 2 == 6 ) local falseStatement = ( 2 - 1 == 1 ) and ( 6 / 2 == 5 ) print ( trueStatement ) print ( falseStatement ) true false You can also use and to check a condition when assigning a value to a variable without using an if statement. Code Output local rightAnswer = ( 2 + 2 == 4 ) and \"right\" -- Since 2 + 2 is indeed 4, it will assign \"right\" to rightAnswer print ( rightAnswer ) right","title":"And"},{"location":"Luau-Learning/operators/#or","text":"or will evaluate as true if one of the conditions are true Code Output local trueStatement = ( 2 + 2 == 69 ) or ( 2 * 2 == 4 ) -- One of these conditions are true, hence it will evaluate as true local falseStatement = ( 6 ^ 6 == 89 ) or ( 2 - 9 == - 420 ) -- Both conditions are false, hence it will evaluate as false print ( trueStatement ) print ( falseStatement ) true false Just like and , you can also use or when assigning values to variables. Code Output local answer = ( 2 + 2 == 5 ) and \"right\" or \"wtf wrong !!!!\" --[[ Since 2 + 2 is not 5, it will assign \"wtf wrong !!!!\" to answer, instead of assigning \"right\" to it. ]] print ( answer ) wtf wrong !!!!","title":"Or"},{"location":"Luau-Learning/operators/#not","text":"not will evaluate as the opposite of the condition. For example, not true --> false , not false --> true Code Output local trueStatement = ( 2 + 2 == 4 ) -- true local falseStatement = ( 2 + 2 == 5 ) -- false print ( not trueStatement ) print ( not falseStatement ) false true","title":"Not"},{"location":"Luau-Learning/operators/#relational","text":"Relational operators are used to compare 2 values and will return a boolean ( true or false )","title":"Relational"},{"location":"Luau-Learning/operators/#equal-to","text":"As the name suggests, this operator checks if one value is equal to another value. Code Output print ( 2 == 1 + 1 ) print ( 3 == 2 ) true false","title":"Equal to (==)"},{"location":"Luau-Learning/operators/#not-equal-to","text":"This operator checks if one value does not equal to another value Code Output print ( \"joe\" ~= \"willie\" ) print ( 1 ~= 0 + 1 ) true false","title":"Not equal to (~=)"},{"location":"Luau-Learning/operators/#greater-than","text":"This operator checks if one value is greater than to another value Code Output print ( 3 > 2 ) print ( - 1 > 4 ) true false","title":"Greater than (&gt;)"},{"location":"Luau-Learning/operators/#less-than","text":"This operator checks if one value is less than to another value Code Output print ( 2 < 3 ) print ( 4 < - 1 ) true false","title":"Less than (&lt;)"},{"location":"Luau-Learning/operators/#greater-than-or-equal-to","text":"This operator checks if one value is great than or equal to to another value Code Output print ( 3 >= 1 ) print ( 3 >= 3 ) print ( 3 >= 5 ) true true false","title":"Greater than or equal to (&gt;=)"},{"location":"Luau-Learning/operators/#less-than-or-equal-to","text":"This operator checks if one value is less than or equal to to another value Code Output print ( 1 <= 3 ) print ( 1 <= 1 ) print ( 5 <= 3 ) true true false","title":"Less than or equal to (&lt;=)"},{"location":"Luau-Learning/operators/#arithmetic","text":"Lua supports the usual binary operators along with exponentiation (^), modulus (%), and unary negation (-). These are pretty self explanatory, so I won't be providing any explanations.","title":"Arithmetic"},{"location":"Luau-Learning/operators/#addition","text":"Code Output print ( 2 + 2 ) print ( 3 + 6 ) 4 9","title":"Addition (+)"},{"location":"Luau-Learning/operators/#subtraction-","text":"Code Output print ( 4 - 2 ) print ( 5 - 2 ) 2 3","title":"Subtraction (-)"},{"location":"Luau-Learning/operators/#multiplication","text":"Code Output print ( 2 * 3 ) print ( 3 * 3 ) 6 9","title":"Multiplication (*)"},{"location":"Luau-Learning/operators/#division","text":"Code Output print ( 6 / 2 ) print ( 1 / 2 ) 3 0.5","title":"Division (/)"},{"location":"Luau-Learning/operators/#exponentiation","text":"Code Output print ( 2 ^ 3 ) print ( 3 ^ 3 ) 8 27","title":"Exponentiation (^)"},{"location":"Luau-Learning/operators/#modulus","text":"Code Output print ( 2 % 2 ) print ( 13 % 6 ) 0 1","title":"Modulus (%)"},{"location":"Luau-Learning/operators/#unary-negation-","text":"Code Output print ( - 4 ) - 4","title":"Unary negation (-)"},{"location":"Luau-Learning/operators/#miscellaneous","text":"Miscellaneous operators include concatenation and length .","title":"Miscellaneous"},{"location":"Luau-Learning/operators/#concatenation","text":"Concatenates 2 values together. You can only concatenate strings and numbers Code Output print ( \"hello \" .. \"world!!!!\" ) hello world !!!!","title":"Concatenation (..)"},{"location":"Luau-Learning/operators/#length","text":"If used on a table, specifically an array , it will return the number of elements in that array. If used on a string , it will return the amount of characters in that string, spaces are counted too Code Output local array = { 1 , 5 , 6 , 8 , 9 } local leString = \"hellooo\" print ( # array ) print ( # leString ) 5 7","title":"Length (#)"},{"location":"Luau-Learning/operators/#thanks-for-reading","text":"If there are any mistakes found in this article, please report the artcile!","title":"Thanks for reading !!!"},{"location":"Others/Help_Us%21/","text":"Reviews We hope, you are having a fun time reading our articles. Your reviews means alot and serve a way to improve our docs. Please give us a detailed review based on your experience experience. Review Reports When reading any of the articles, if you find any mistake then please report us with article name and mention the mistake in as much details, as possible. Report","title":"Help Us!"},{"location":"Others/Help_Us%21/#reviews","text":"We hope, you are having a fun time reading our articles. Your reviews means alot and serve a way to improve our docs. Please give us a detailed review based on your experience experience. Review","title":"Reviews "},{"location":"Others/Help_Us%21/#reports","text":"When reading any of the articles, if you find any mistake then please report us with article name and mention the mistake in as much details, as possible. Report","title":"Reports"},{"location":"Others/contributors/","text":"Contributors EdenRose#1968 Miscellaneous Manager *willi#8890 Former Miscellaneous Manager remi#1426 Former Miscellaneous Manager shotgunck#4239 Senior Helper Kepe#5235 Senior Helper Teerach#9553 Senior Helper sl0th#5669 Senior Helper Salzu#2773 Helper Paper#9031 Helper Special thanks to them and the rest of helper team!","title":"Contributors"},{"location":"Others/contributors/#contributors","text":"EdenRose#1968 Miscellaneous Manager *willi#8890 Former Miscellaneous Manager remi#1426 Former Miscellaneous Manager shotgunck#4239 Senior Helper Kepe#5235 Senior Helper Teerach#9553 Senior Helper sl0th#5669 Senior Helper Salzu#2773 Helper Paper#9031 Helper Special thanks to them and the rest of helper team!","title":"Contributors"},{"location":"Tutorials/","text":"Welcome to tutorials section Here you will can find tutorials and which will enhance your learning experience! You can find tutorials of all categories, all topics, and everything that we think is useful to know, as long as it has to do with being a video game developer of course. Our main objective is to encourage people to learn something new whenever they can, that's why we want to make a special site for it, in which you can expand your knowledge.","title":"Welcome to tutorials section"},{"location":"Tutorials/#welcome-to-tutorials-section","text":"Here you will can find tutorials and which will enhance your learning experience! You can find tutorials of all categories, all topics, and everything that we think is useful to know, as long as it has to do with being a video game developer of course. Our main objective is to encourage people to learn something new whenever they can, that's why we want to make a special site for it, in which you can expand your knowledge.","title":"Welcome to tutorials section"},{"location":"Tutorials/Scripting/Detecting_Keyboard_Inputs/","text":"Detecting Keyboard Inputs With UserInputService In this tutorial, I will be showing you how to detect keyboard inputs with UserInputService . If you don't have a basic understanding of Lua and Roblox scripting I would recommend starting here before going through this tutorial. Otherwise, you may get confused when we get into Events and other things. What is UserInputService? UserInputService is a neat API Service that Roblox has put together to help up manage a client's user input, hence the name. A popular alternative to UserInputService is ContextActionService which is sometimes preferred when you are working with input for different devices (mobile/console). Getting Started First, we are going to need our LocalScript , for this tutorial, I will be putting it under StarterPlayerScripts and will be calling it Sprint . However, you can put this anywhere in a valid location for a LocalScript: Valid LocalScript Locations: A Players Backpack, such as a child of a Tool A Players character model A Players PlayerGui A Players PlayerScripts. The ReplicatedFirst service The Fun Part Now that we have our LocalScript, we can start getting into it. First we are going to need to create a reference to UserInputService: local UserInputService = game : GetService ( 'UserInputService' ) You can learn more about GetService here Now that we have a reference to UserInputService we can start using it's functions and events. We will be using InputBegan and InputEnded Before we make our events, I am going to define our sprint key as a constant. Using the global Enums that Roblox has made for us. I will also be defining our LocalPlayer which we can use to get our Character . You can find a complete list of KeyCodes here local UserInputService = game : GetService ( 'UserInputService' ) local SPRINT_KEY = Enum . KeyCode . LeftShift local Player = game . Players . LocalPlayer Now that we have our sprint key defined we can make our events: local UserInputService = game : GetService ( 'UserInputService' ) local SPRINT_KEY = Enum . KeyCode . LeftShift UserInputService . InputBegan : Connect ( function ( InputObject , GameProcessed ) end ) UserInputService . InputEnded : Connect ( function ( InputObject ) end ) As you can see, InputBegan and InputEnded both have a parameter: InputObject this is the object that contains all the information for the input that fired the event. This is how we can determine what key was pressed. In the InputBegan event, you can see a second parameter called GameProcessed , this is a boolean value that will be true if the input that fired the event is being used by Roblox, this can be used to avoid doing something if a player is typing something in the Roblox chat. But for our tutorial, I will be ignoring that parameter because I want people to be able to sprint if they press the Shift Key, which can also be used for ShiftLock . Now that we have our events, we need to make sure the key being pressed is our sprint key: if ( InputObject . KeyCode == SPRINT_KEY ) then Then inside that if statement , we can get our Character and Humanoid : local Character = Player . Character or Player . CharacterAdded : Wait () local Humanoid = Character : WaitForChild ( 'Humanoid' ) Once we have the Humanoid we can set the WalkSpeed property to make the character sprint: local UserInputService = game : GetService ( 'UserInputService' ) local SPRINT_KEY = Enum . KeyCode . LeftShift UserInputService . InputBegan : Connect ( function ( InputObject , GameProcessed ) if ( InputObject . KeyCode == SPRINT_KEY ) then local Character = Player . Character or Player . CharacterAdded : Wait () local Humanoid = Character : WaitForChild ( 'Humanoid' ) Humanoid . WalkSpeed = 25 end end ) UserInputService . InputEnded : Connect ( function ( InputObject ) end ) Then finally, if we add that same code to our InputEnded event, and reverse the WalkSpeed : local UserInputService = game : GetService ( 'UserInputService' ) local SPRINT_KEY = Enum . KeyCode . LeftShift UserInputService . InputBegan : Connect ( function ( InputObject , GameProcessed ) if ( InputObject . KeyCode == SPRINT_KEY ) then local Character = Player . Character or Player . CharacterAdded : Wait () local Humanoid = Character : WaitForChild ( 'Humanoid' ) Humanoid . WalkSpeed = 25 end end ) UserInputService . InputEnded : Connect ( function ( InputObject ) if ( InputObject . KeyCode == SPRINT_KEY ) then local Character = Player . Character or Player . CharacterAdded : Wait () local Humanoid = Character : WaitForChild ( 'Humanoid' ) Humanoid . WalkSpeed = 16 end end ) Done Hey Presto! If you followed this tutorial correctly, your character should speed up while you are holding the SPRINT_KEY and go back to normal when you release the key. I hope you enjoyed learning about UserInputService . Learning Resources","title":"Detecting Keyboard Inputs With UserInputService"},{"location":"Tutorials/Scripting/Detecting_Keyboard_Inputs/#detecting-keyboard-inputs-with-userinputservice","text":"In this tutorial, I will be showing you how to detect keyboard inputs with UserInputService . If you don't have a basic understanding of Lua and Roblox scripting I would recommend starting here before going through this tutorial. Otherwise, you may get confused when we get into Events and other things.","title":"Detecting Keyboard Inputs With UserInputService"},{"location":"Tutorials/Scripting/Detecting_Keyboard_Inputs/#what-is-userinputservice","text":"UserInputService is a neat API Service that Roblox has put together to help up manage a client's user input, hence the name. A popular alternative to UserInputService is ContextActionService which is sometimes preferred when you are working with input for different devices (mobile/console).","title":"What is UserInputService?"},{"location":"Tutorials/Scripting/Detecting_Keyboard_Inputs/#getting-started","text":"First, we are going to need our LocalScript , for this tutorial, I will be putting it under StarterPlayerScripts and will be calling it Sprint . However, you can put this anywhere in a valid location for a LocalScript: Valid LocalScript Locations: A Players Backpack, such as a child of a Tool A Players character model A Players PlayerGui A Players PlayerScripts. The ReplicatedFirst service","title":"Getting Started"},{"location":"Tutorials/Scripting/Detecting_Keyboard_Inputs/#the-fun-part","text":"Now that we have our LocalScript, we can start getting into it. First we are going to need to create a reference to UserInputService: local UserInputService = game : GetService ( 'UserInputService' ) You can learn more about GetService here Now that we have a reference to UserInputService we can start using it's functions and events. We will be using InputBegan and InputEnded Before we make our events, I am going to define our sprint key as a constant. Using the global Enums that Roblox has made for us. I will also be defining our LocalPlayer which we can use to get our Character . You can find a complete list of KeyCodes here local UserInputService = game : GetService ( 'UserInputService' ) local SPRINT_KEY = Enum . KeyCode . LeftShift local Player = game . Players . LocalPlayer Now that we have our sprint key defined we can make our events: local UserInputService = game : GetService ( 'UserInputService' ) local SPRINT_KEY = Enum . KeyCode . LeftShift UserInputService . InputBegan : Connect ( function ( InputObject , GameProcessed ) end ) UserInputService . InputEnded : Connect ( function ( InputObject ) end ) As you can see, InputBegan and InputEnded both have a parameter: InputObject this is the object that contains all the information for the input that fired the event. This is how we can determine what key was pressed. In the InputBegan event, you can see a second parameter called GameProcessed , this is a boolean value that will be true if the input that fired the event is being used by Roblox, this can be used to avoid doing something if a player is typing something in the Roblox chat. But for our tutorial, I will be ignoring that parameter because I want people to be able to sprint if they press the Shift Key, which can also be used for ShiftLock . Now that we have our events, we need to make sure the key being pressed is our sprint key: if ( InputObject . KeyCode == SPRINT_KEY ) then Then inside that if statement , we can get our Character and Humanoid : local Character = Player . Character or Player . CharacterAdded : Wait () local Humanoid = Character : WaitForChild ( 'Humanoid' ) Once we have the Humanoid we can set the WalkSpeed property to make the character sprint: local UserInputService = game : GetService ( 'UserInputService' ) local SPRINT_KEY = Enum . KeyCode . LeftShift UserInputService . InputBegan : Connect ( function ( InputObject , GameProcessed ) if ( InputObject . KeyCode == SPRINT_KEY ) then local Character = Player . Character or Player . CharacterAdded : Wait () local Humanoid = Character : WaitForChild ( 'Humanoid' ) Humanoid . WalkSpeed = 25 end end ) UserInputService . InputEnded : Connect ( function ( InputObject ) end ) Then finally, if we add that same code to our InputEnded event, and reverse the WalkSpeed : local UserInputService = game : GetService ( 'UserInputService' ) local SPRINT_KEY = Enum . KeyCode . LeftShift UserInputService . InputBegan : Connect ( function ( InputObject , GameProcessed ) if ( InputObject . KeyCode == SPRINT_KEY ) then local Character = Player . Character or Player . CharacterAdded : Wait () local Humanoid = Character : WaitForChild ( 'Humanoid' ) Humanoid . WalkSpeed = 25 end end ) UserInputService . InputEnded : Connect ( function ( InputObject ) if ( InputObject . KeyCode == SPRINT_KEY ) then local Character = Player . Character or Player . CharacterAdded : Wait () local Humanoid = Character : WaitForChild ( 'Humanoid' ) Humanoid . WalkSpeed = 16 end end )","title":"The Fun Part"},{"location":"Tutorials/Scripting/Detecting_Keyboard_Inputs/#done","text":"Hey Presto! If you followed this tutorial correctly, your character should speed up while you are holding the SPRINT_KEY and go back to normal when you release the key. I hope you enjoyed learning about UserInputService . Learning Resources","title":"Done"},{"location":"Tutorials/Scripting/Leaderstats/","text":"Leaderstats Leaderstats/Leaderboard is the board that appears on the right top of the player's screen. If you are used to playing games on Roblox then you must have seen this in many games. How to create one? Making a leader stats is pretty simple. First of all we will add a script in ServerScriptService . For making leader stats, we have to add a folder inside every player and name it leaderstats . Once made the folder, we will add value objects such as IntValue , NumberValue , StringValue etc. In the script, we will get every player that joins the game and create leader stats for it. To get each player, we will connect a function to PlayerAdded . In the function, we will create the folder for leader stats and set values inside it. local function stats_handler ( player ) local leaderstats = Instance . new ( \"Folder\" ) leaderstats . Name = \"leaderstats\" leaderstats . Parent = player local points = Instance . new ( \"IntValue\" ) points . Name = \"Points\" points . Parent = leaderstats end game . Players . PlayerAdded : Connect ( stats_handler ) In the first part of stats_handler we created a folder using instance.new() and named it leaderstats and lastly parented it to the Player . The player was returned by PlayerAdded . In the second part, we created an IntValue , named it \"Points\" and set its parent to the leaderstats folder. Now, if you press f5 to run the game. You can see leaderstats on your screen. Caution The folder must be exactly named as leaderstats . In case of any misspelling or capitalizing, the Roblox engine will not create the leaderboard. Setting Values Once created leaderstats you can set values by changing the Value property of IntValue . local function stats_handler ( player ) local leaderstats = Instance . new ( \"Folder\" ) leaderstats . Name = \"leaderstats\" leaderstats . Parent = player local points = Instance . new ( \"IntValue\" ) points . Name = \"Points\" points . Parent = leaderstats points . Value = 100 end game . Players . PlayerAdded : Connect ( stats_handler ) No, if you run the game. Your points will be 100 . Implementing As an example of usage. Create a part in the workspace and add ClickDetector to it. You can either make a separate script or use the ordinary one. We will use MouseClick event of ClickDetector which is fired whenever a player interacts with it. This event also returns that Player . workspace . Part . ClickDetector . MouseClick : Connect ( function ( player ) player . leaderstats . Value = player . leaderstats . Points . Value + 1 end ) Now every time you click the part. It will increase your points by 1 Closing! As always, we hope you enjoyed reading and can utilize leaderstats according to your needs. Whatever you are learning, please practice it on the spot. Just reading will not help you if you aren't practicing them. In case of any mistakes, typos, etc please report the article!","title":"Leaderstats"},{"location":"Tutorials/Scripting/Leaderstats/#leaderstats","text":"Leaderstats/Leaderboard is the board that appears on the right top of the player's screen. If you are used to playing games on Roblox then you must have seen this in many games.","title":"Leaderstats"},{"location":"Tutorials/Scripting/Leaderstats/#how-to-create-one","text":"Making a leader stats is pretty simple. First of all we will add a script in ServerScriptService . For making leader stats, we have to add a folder inside every player and name it leaderstats . Once made the folder, we will add value objects such as IntValue , NumberValue , StringValue etc. In the script, we will get every player that joins the game and create leader stats for it. To get each player, we will connect a function to PlayerAdded . In the function, we will create the folder for leader stats and set values inside it. local function stats_handler ( player ) local leaderstats = Instance . new ( \"Folder\" ) leaderstats . Name = \"leaderstats\" leaderstats . Parent = player local points = Instance . new ( \"IntValue\" ) points . Name = \"Points\" points . Parent = leaderstats end game . Players . PlayerAdded : Connect ( stats_handler ) In the first part of stats_handler we created a folder using instance.new() and named it leaderstats and lastly parented it to the Player . The player was returned by PlayerAdded . In the second part, we created an IntValue , named it \"Points\" and set its parent to the leaderstats folder. Now, if you press f5 to run the game. You can see leaderstats on your screen. Caution The folder must be exactly named as leaderstats . In case of any misspelling or capitalizing, the Roblox engine will not create the leaderboard.","title":"How to create one?"},{"location":"Tutorials/Scripting/Leaderstats/#setting-values","text":"Once created leaderstats you can set values by changing the Value property of IntValue . local function stats_handler ( player ) local leaderstats = Instance . new ( \"Folder\" ) leaderstats . Name = \"leaderstats\" leaderstats . Parent = player local points = Instance . new ( \"IntValue\" ) points . Name = \"Points\" points . Parent = leaderstats points . Value = 100 end game . Players . PlayerAdded : Connect ( stats_handler ) No, if you run the game. Your points will be 100 .","title":"Setting Values"},{"location":"Tutorials/Scripting/Leaderstats/#implementing","text":"As an example of usage. Create a part in the workspace and add ClickDetector to it. You can either make a separate script or use the ordinary one. We will use MouseClick event of ClickDetector which is fired whenever a player interacts with it. This event also returns that Player . workspace . Part . ClickDetector . MouseClick : Connect ( function ( player ) player . leaderstats . Value = player . leaderstats . Points . Value + 1 end ) Now every time you click the part. It will increase your points by 1","title":"Implementing"},{"location":"Tutorials/Scripting/Leaderstats/#closing","text":"As always, we hope you enjoyed reading and can utilize leaderstats according to your needs. Whatever you are learning, please practice it on the spot. Just reading will not help you if you aren't practicing them. In case of any mistakes, typos, etc please report the article!","title":"Closing!"}]}